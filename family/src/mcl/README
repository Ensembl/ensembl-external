
0. CONTENTS

   1. Unpacking
   2. The utilities
   3. Matrix/graph input and output formats used by MCL.

      3.1   Representing matrices and graphs.
      3.2   Binary format and ascii format.
      3.3   Ascii header information and matrix specification.
      3.4   Ascii [node/edge | column] specification.
      3.5   Clusterings are output in matrix format.
      3.6   Ascii format examples, (mcl input and output).

   See http://members.ams.chello.nl/svandong/thesis/index.html for
   additional information.

1. Unpacking

   This distribution does not install itself in one of the standard
   system directories. Compilation was tested on the Debian GNU/Linux
   system. Since the software is quite generic and does not need system
   directories, it should be simple to compile this under other Unices.
   Perhaps you have to diddle the Makefile a little - the aim is to make
   this more generic in the near future. Note that the setup is very
   much GNU inclined, using GNU-specific Makefile and compiler options.

   What you do is simply unpack the tarball somewhere, using `tar xzf
   mcl.tgz'. A directory mcl/ is created, and everything is contained
   within it.  Then the command `make binaries' should create the binaries
   in the bin/ directory.

   The directory graphs/ contains a few graphs in ascii format that
   you can use to experiment with mcl.  In the directory test/ you find
   symlinks to these graphs, so you can do the testing there and keep
   graphs/ clean.


2. The utilities

 O
   o  mcl            The cluster program. Lots of options, but just a few
                     will get you going. You can even get away with none:
                     `mcl <file name>' where file name contains a graph
                     in MCL matrix/graph format causes mcl to happily
                     cluster your stuff, using the default settings.

                     See the -h flag and the www documentation pointed to
                     above for more information on using mcl.

 O
   o  mcxmorph       Is capable of transposing matrices, normalizing matrices,
                     making matrices characteristic, pruning matrices,
                     multiplying matrices, and all of these sequentially.

   o  mcxconvert     Convert matrices from binary to ascii format or vice versa

   o  mcxview        View matrices (yields long listing of entries).

   o  mcxsubs        Supports extraction of submatrices induced by clusters,
                     simple indices, and complements and combinations of these.
                     Both diagonal and off-diagonal submatrices are supported,
                     and indices can be tagged according to the cluster they
                     are in.

 O
   o  clmdist        Compute the split/join distance between two clusterings.
                     The clusterings must be in one of the native matrix
                     formats (they will be if generated by mcl). Moreover,
                     the first clustering must be covering, that is,
                     each element must be contained in a cluster.

   o  clminfo        Generate performance measures for clustering relative
                     to input graph.

   o  clmmeet        Do not let the mumble jumble below let you fool into
                     thinking that clmmeet is not interesting.
                     It is *very* interesting for checking the consistency
                     of a set of clusterings on different scales of
                     granularity, used in combination with clmdist.

                     clmmeet computes the meet of a list of clusterings.
                     The meet of just *two* clusterings C1 and C2 is the
                     unique clustering D such that D is a super-clustering
                     of all clusterings C that are a sub-clustering of
                     both C1 and C2, so that D is the largest clustering
                     that is a subclustering of both C1 and C2.  The meet
                     D has the property that

                        d(C1,C2) = d(C1,D) + d(D,C2)

                     where d is the split/join distance computed by
                     clmdist.  To be fully accurate: given the input C1
                     and C2 clmdist returns the pair [d(C1,D) , d(D,C2)].
                     The definition of meet for an arbitrary number of
                     clusterings is a straightforward generalization of
                     the above.

   o  clmproject     Generates performance measures for each cluster and
                     node separately. Shows how well a node fits in a cluster
                     and how cohesive a given cluster is.




3. Matrix/graph input and output formats used by MCL.


   3.1   Representing matrices and graphs.
   3.2   Binary format and ascii format.
   3.3   Ascii header information and matrix specification.
   3.4   Ascii [node/edge | column] specification.
   3.5   Clusterings are output in matrix format.
   3.6   Ascii format examples, (mcl input and output).


3.1   Representing matrices and graphs.


   In the MCL setting, square matrices and graphs are exactly the same
   thing in different languages. This is because matrices are always
   assumed to be nonnegative, and graphs can be directed and weighted
   with positive weight function, and are allowed to have loops.
   This is somewhat elaborated upon below.

   A matrix is a rectangular array with K rows and L columns.  In the
   MCL library, matrices are always nonnegative. This means that entries
   in the array are real numbers represented by nonnegative floats. The
   representation used is *sparse*, that is, zero entries are not stored.
   The routines in the MCL library are tailored to the particular
   data-structures that encode matrices and vectors as sparse objects.
   Moreover the MCl routines assume (and sometimes check) whether matrix
   entries are indeed nonnegative; negative entries may cause errors.

   In MCL a matrix is stored as a listing of columns. For each column,
   the list of row entries is maintained for which the corresponding
   matrix entries are positive -- together with the entry itself.
   The smallest building block is a so called Index Value Pair, which is
   implementation-wise a struct with one int member and one float member.
   A column (vector) is a list of index value pairs, and a matrix is a
   list of column vectors.


   A graph is a set of nodes with (directed) edges going from one node,
   the tail node, to a second node, the head node (which may equal the
   tail node).  Each edge has a positive weight, and is fully defined
   by the weight and the tail node and head node.  A standard way of
   representing a graph as a matrix is by enumerating the nodes 0,..,K-1
   and by creating a matrix M of dimensions <K>x<K> where M[i,j] ==
   0 iff there is no edge from j to i, and where M[i,j] == w(i,j) iff
   there is an edge from j to i with weight w(i,j).  Note that for most
   purposes in graph theory, it is generally true that one may identify
   the absence of an edge between two nodes with the presence of an edge
   with weight zero. Vice versa, a nonnegative matrix can be identified
   with a weighted graph by appropriately letting positive matrix entries
   induce edges between the tail node (identified by the column index)
   and the head node (identified by the row index).  In this setup, column
   j corresponds with all edges and edge weights that have j as tail node.


   Matrices are thus used for encoding graphs in the obvious, well
   established manner. They are also used for other purposes, e.g. for
   encoding transition matrices (again obvious) and also for encoding
   cluster output (perhaps slightly less obvious - see below).


3.2   Binary format and ascii format.


   There are two formats for matrices: ascii format and binary format.
   The binary format includes a `magic number' at the start of file.
   The binary format is useful for very large graphs, as input/output is
   then a lot faster.  A format conversion program for matrices exists and
   is called mcxconvert; it recognizes the format of its first argument,
   and writes the same matrix in the other format to the file name found
   in the second argument.

   Note that MCL does not suppose or support file extensions. It is
   able to see whether a file is in binary format or in ascii format.
   You are totally free to choose your own conventions, for example to
   distinguish mcl output from mcl input.



3.3   Ascii header information and matrix specification.


   The matrix ascii specificiation consists of two parts, the header
   and the matrix itself.  The start of the header is indicated by the string

   '(mclheader'

   It should preferably be at the beginning of a new line.  The end of
   the header is indicated by a closing parenthesis at the beginning of
   a line,

   ')'

   The lines inbetween consist of a KEY string and a VALUE string,
   separated by whitespace. The order of listing is arbitrary.
   Two key/value pairs must be specified. These are

   'mcltype matrix'                    (fixed value)
   'dimensions <int K>x<int L>

   A valid header thus is

   (mclheader
   mcltype  matrix
   dimensions  12x12
   )

   For graphs K and L must be equal. In the more general case, K denotes
   the number of rows, and L denotes the number of columns of the matrix
   (note that matrices are stored column-wise in the mcl library).

   Other information can be stored in the header, MCL cares only about
   keys it recognizes. Note that other keys might become meaningful in
   the future though.

   The matrix itself is specified by the sequence

   (mclmatrix
   begin
   _____ Node/edge specification, described below, Examples are also given
   _____ below.
   _____
   _____ The matrix specification should be closed by a parenthesis on a line
   _____ by itself, just like the header.
   )


3.4   Ascii [node/edge | column] specification.

   If the dimensions are KxL, then column indices must be in the range
   of integers 0,..,K-1, and row indices must be in the range 0,..,L-1.
   The ascii specification can be worded either in terms of graphs (in
   which case it is demanded that K equals L), or in terms of matrices.
   Please note:

   THE RULE IN MCL MATRIX ENCODING is that the set of all edges originating
   from a given tail node corresponds with a matrix column.


GRAPH FORMULATION

   In ASCII format, edges are specified relative to the tail node.
   The `begin' keyword in the `(mclmatrix' part is followed by a list of
   listings, where the primary list ranges over all nodes in the graph,
   and where each secondary lists encodes all the edges that have the
   corresponding node as tail node.

   For each tail node i, all the nodes j reached by i are listed, together
   with the weight of the corresponding edge. A tail node listing starts
   with the index i of the tail node itself, and is closed with the '$'
   character.

   An edge specification for a given node j (where j is an index, c.q.
   an integer) reached by tail node i (which is part of the listing for i)
   looks either as `j:f', where f denotes a nonnegative real, or simply as
   `j'. In the first case, the weight of the edge from i to j equals f,
   in the latter case, this weight will by default equal 1. These two
   types of edge specification may be mixed (though this is strongly
   advised against because it is confusing).  See below for examples.


MATRIX FORMULATION

   In ASCII format, a matrix M is specified column-wise.  The `begin'
   keyword in the `(mclmatrix' part is followed by a list of listings,
   where the primary list ranges over all columns in M, and where each
   secondary lists encodes all positive entries in the corresponding
   column. A secondary list (or matrix column) starts with the index c
   of the column, and then contains a listing of all row entries in c
   (these are matrix entries M[r,c] for varying r). The entry M[r,c]
   is specified either as `r' or as `r:f', where f is a float.  In the
   first case, the entry M[r,c] defaults to 1.0,  in the second case,
   it is set to f. The secondary list is closed with the `$' character.


3.5   Clusterings are output in matrix format.


   Clusterings are output in matrix format. Each column of the matrix is
   the characteristic vector of a particular cluster in the clustering.
   Now suppose the output is in ascii format.  The quantity M in the
   dimension specification denotes the number of rows. In this case,
   the number of rows is the range in which cluster elements exist, which
   is exactly the number of nodes in the input graph. The quantity M is
   the number of columns, and this is precisely the number of clusters,
   as each column represents one cluster. Below you will find an example.

   The following are two examples of ascii format for the same simple
   graph.  They are followed by the clustering output (in ascii format)
   resulting from applying mcl with default parameters to this graph.


3.6   Ascii format examples, (mcl input and output).


--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8

   This comment may appear in the ascii matrix source.
   The following graph is used several times in the reports at
   http://www.cwi.nl/static/publications/reports/INS-2000.html
   It is named small.mci in the directories graphs and test.
   A picture of this graph is found in graphs/small.ps and
   graphs/small.png.

(mclheader
mcltype matrix
dimensions 12x12
)

(mclmatrix
begin
0 1 5 6 9 $
1 0 2 4 $
2 1 3 4 $
3 2 7 8 10 $
4 1 2 6 7 $
5 0 9 $
6 0 4 9 $
7 3 4 8 10 $
8 3 10 7 11 $
9 0 5 6 $
10 3 7 8 11 $
11 10 8 $
)

--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8--->8

   This comment may appear in the ascii matrix source.
   The following graph is used several times in the reports at
   http://www.cwi.nl/static/publications/reports/INS-2000.html It is
   named small.mci in the directories graphs and test.  A picture of
   this graph is found in graphs/small.ps and graphs/small.png.

   The line `0 1:1.0 5:1.0 6:1.0 9:1.0 $' means that node 0 has neighbours
   1, 5, 6, and 9, and each arc going to these neighbours has weight 1.0
   attached to it. Changing the line to `0 1:1.34 5:10.3 6:0.00001 9:1 $'
   means the obvious thing.

(mclheader
mcltype matrix
dimensions 12x12
)

(mclmatrix
begin
0 1:1.0 5:1.0 6:1.0 9:1.0 $
1 0:1.0 2:1.0 4:1.0 $
2 1:1.0 3:1.0 4:1.0 $
3 2:1.0 7:1.0 8:1.0 10:1.0 $
4 1:1.0 2:1.0 6:1.0 7:1.0 $
5 0:1.0 9:1.0 $
6 0:1.0 4:1.0 9:1.0 $
7 3:1.0 4:1.0 8:1.0 10:1.0 $
8 3:1.0 10:1.0 7:1.0 11:1.0 $
9 0:1.0 5:1.0 6:1.0 $
10 3:1.0 7:1.0 8:1.0 11:1.0 $
11 10:1.0 8:1.0 $
)

---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<

   !¯¯!  This matrix embodies example mcl output   !¯¯!
   !__!  It cannot be used as example mcl input    !__!

   This comment may appear in the ascii matrix source.
   This is the clustering resulting from applying mcl with default
   parameters to the graph above, in mcl matrix encoding.

(mclheader
mcltype matrix
dimensions 12x3
)
(mclmatrix
begin
0    1  2  4 $
1    0  5  6  9 $
2    3  7  8 10 11 $
)
---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<---8<


 The mcl algorithm writes a matrix file which represents a clustering.
 Each column of this matrix represents a cluster. Theoretically, it
 can happen that an mcl limit induces a clustering with overlap in it.
 This will almost surely not happen for real-life cases. However, *if*
 it happens MCl will by default remove the overlap, ensuring that the
 output clustering is strictly a partition of the node set (each node
 is in exactly one cluster). This behaviour can be changed using the
 --overlap flag.

 One can direct cluster output to STDOUT by setting "-o -".  This will
 send the matrix representing the clustering to STDOUT in ascii format.


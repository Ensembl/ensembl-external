/*
// compose.c            MCL specific compose
*/

#include <math.h>
#include <limits.h>
#include <float.h>

#include "nonema/compose.h"
#include "nonema/ivp.h"
#include "nonema/vector.h"
#include "nonema/iface.h"

#include "mcl/compose.h"
#include "mcl/iface.h"

#include "util/alloc.h"
#include "util/iface.h"
#include "util/minmax.h"


static const char* LOC_TRACK_PRUNING  =  "trackPruning compose";

int   mclMassNx   =  10;
int   mclMassNy   =  100;


typedef struct
{
   float val
;  int   n_gt
;  int   idx
;
}  hint  ;


int         hintScores[5];
static hint hintList[5];


int hintCmp
(  
   const void* h1
,  const void* h2
)  ;


int hintCmp
(  
   const void* h1
,  const void* h2
)  
   {  
      return ( ((hint*) h1)->n_gt - ((hint*) h2)->n_gt )
;  }


mcxComposeParam* mcxComposeParamNew
(  void
)  
   {  
      mcxComposeParam *cpParam      =     (mcxComposeParam*) rqAlloc
                                          (  sizeof(mcxComposeParam)
                                          ,  EXIT_ON_FAIL
                                          )

   ;  cpParam->maxDensity           =     mclDefaultMaxDensity
   ;  cpParam->precision            =     (float)
                                          pow(10.0,-mclDefaultPrecisionExponent)
   ;  cpParam->precisionExponent    =     mclDefaultPrecisionExponent
   ;  cpParam->alwaysBarWeight      =     mclDefaultAlwaysBarWeight
   ;  cpParam->threeTwoWeight       =     mclDefaultThreeTwoWeight
   ;  cpParam->centerWeight         =     mclDefaultCenterWeight
   ;  cpParam->cubeWeight           =     mclDefaultCubeWeight
   ;  cpParam->maxValWeight1        =     mclDefaultMaxValWeight1
   ;  cpParam->maxValWeight2        =     mclDefaultMaxValWeight2
   ;  return cpParam
;  }


mcxMatrix* mcxFlowCompose
(  
   const mcxMatrix*        mx1
,  const mcxMatrix*        mx2
,  mcxComposeParam*        param
,  mcxComposeStats*        stats
)
   {  
      mcxMatrix*           mx_d
   ;  int                  mx2col               =  0

   ;  int                  maxDensity           =  param->maxDensity
   ;  float                alwaysBarWeight      =  param->alwaysBarWeight
   ;  float                threeTwoWeight       =  param->threeTwoWeight
   ;  float                centerWeight         =  param->centerWeight
   ;  float                cubeWeight           =  param->cubeWeight
   ;  float                maxValWeight1        =  param->maxValWeight1
   ;  float                maxValWeight2        =  param->maxValWeight2
   ;  mcxIvp*              maxDensityIvp        =  mcxIvpCreate(maxDensity, 0.0)
                                               
   ;  float                precision            =  param->precision
   ;  float                matrixInhomogeneity  =  0.0
                                               
   ;  int                  mainTrackPruning     =  mcxTrackNonemaPruning
   ;  int                  n_full
   ;  float                reduce

   ;  mcxComposeStatsReset(stats)

   ;  {  int   x
      ;  for (x=0;x<5;x++)
         hintScores[x] = 0
   ;  }
                                       /* the code in the following line   */
                                       /* affects mcxMatrixVectorCompose   */
   ;  mcxIvpStorageAllocated((mx2->N_rows)+1)

   ;  if (mx1->N_cols != mx2->N_rows)
      {  fprintf
         (  stderr
         ,  "[mcxFlowExpand PBD] "
            "Incompatible size matrices for compose operation\n"
         )
      ;  exit(1)
   ;  }

   ;  mx_d = mcxMatrixAllocZero(mx1->N_rows, mx2->N_cols)

   ;  if (mainTrackPruning)
         fprintf
         (  mcxTrackStreamNonema->fp
         ,  "____ [%s] at start\n"
         ,  LOC_TRACK_PRUNING
         )

   ;  for (mx2col=0;mx2col<mx2->N_cols;mx2col++)

      {  
         mcxVector*  vec_d       =  mx_d->vectors + mx2col

      ;  float    alwaysBar
               ,  maxval
               ,  cube
               ,  center
               ,  threeTwo
               ,  mass
               ,  vectorInhomogeneity

      ;  if (mclProgress && (mx2col % mclProgress) == 0)
            fwrite(".", sizeof(char), 1, stdout)
         ,  fflush(stdout)

      ;  mcxTrackNonemaPruning
         =  
            mainTrackPruning

      && (  !mcxTrackNonemaPruningOfset
         || mx2col >= mcxTrackNonemaPruningOfset
         )

      && (  !mcxTrackNonemaPruningBound
         || mx2col < mcxTrackNonemaPruningBound
         )

      && (  (  (mx2col-mcxTrackNonemaPruningOfset)
             %  mcxTrackNonemaPruningInterval
            )
            == 0
         )

      ;  if (mclBdense)
         mcxMatrixVectorDenseCompose
         (  mx1
         ,  mx2->vectors + mx2col
         ,  vec_d
         )
      ;  else
         mcxMatrixVectorCompose
         (  mx1
         ,  mx2->vectors + mx2col
         ,  vec_d
         )

      ;  if (mcxTrackNonemaPruning)
         fprintf
         (  mcxTrackStreamNonema->fp
         ,  "\n[%s] vector %d, size %d\n"
         ,  LOC_TRACK_PRUNING, mx2col, vec_d->n_ivps
         )

      ;  n_full   =  vec_d->n_ivps ? vec_d->n_ivps : maxDensity

      ;  if (stats->dbAllocated)
         mcxDistrStoreValue(stats->vDb, (float) n_full )

      ;  reduce   =     maxDensity < n_full
                     ?  ((float ) maxDensity) / (float ) n_full
                     :  0.0
      ;
/*
 *    So far normal matrix multiplication. In the following some options are
 *    implemented which enable different ways of pruning the vector just
 *    computed, vec_d.
*/
         /*
          *    full matrix computation
         */

         if (mclBdense)
         {
            mcxDistrStoreValue(stats->vDb, vec_d->n_ivps )

         ;  if (precision)
            mcxVectorSelectGqBar (vec_d, precision)

         ;  mcxDistrStoreValue(stats->pDb, vec_d->n_ivps )
      ;  }

        /*
         *     Straightforward k pruning.
        */

         else if (mclHeapPruning)
         {
            float f  =  -1.0

         ;  if (2*maxDensity < vec_d->n_ivps)
            f
            =  mcxVectorKBar
               (  vec_d
               ,  maxDensity
               ,  FLT_MAX
               ,  NULL
               ,  KBAR_SELECT_LARGE
               )
         ;  else if (maxDensity < vec_d->n_ivps)
            f
            =  mcxVectorKBar
               (  vec_d
               ,  vec_d->n_ivps - maxDensity+1
               ,  FLT_MAX
               ,  NULL
               ,  KBAR_SELECT_SMALL
               )

         ;  if (f > 0.0)
            mcxVectorSelectGqBar(vec_d, f)
      ;  }

        /*
         *     Elaborate pruning scheme using hints.
         *     hierverder: bereken ik alle thresholds ook als
         *     vec->n_ivps <= maxDensity ?
        */

         else
         {
            int   n_pruned, n_bestHint

         ;  maxval    =    mcxVectorMaxValue(vec_d)
         ;  threeTwo  =    (float) pow((double)mcxVectorPowSum(vec_d, 1.5), 2.0)

         ;  alwaysBar =    (  threeTwo
                           *  (float) pow
                              (  1.01 - reduce
                              ,  2.0
                              )
                           *  (float) pow
                              (  1.01 - (threeTwo / maxval)
                              ,  2.0
                              )
                           /  alwaysBarWeight
                           )

         ;  if (mclBsqueeze)
            {  
               mcxVectorSelectGqBar(vec_d, alwaysBar)

            ;  mass              =  mcxVectorSum(vec_d)
            ;  mass              =  mass ? mass : 1.0

            ;  cube              =     sqrt(mcxVectorPowSum(vec_d, 3.0))
                                    /  (mass*mass)
            ;  center            =     mcxVectorPowSum(vec_d, 2.0)
                                    /  mass
         ;  }
            else
            {  cube              =  sqrt(mcxVectorPowSum(vec_d, 3.0))
            ;  center            =  mcxVectorPowSum(vec_d, 2.0)

            ;  mcxVectorSelectGqBar(vec_d, alwaysBar)
            ;  mass              =  mcxVectorSum(vec_d)
         ;  }

         ;  n_pruned = vec_d->n_ivps

         ;  if (mcxTrackNonemaPruning)
               fprintf
               (  mcxTrackStreamNonema->fp
               ,  " max       cub       ctr       tTw"
                      "       bar       kept mass #kept\n"
                  " %.6f  %.6f  %.6f  %.6f [%.6f, %.6f, %d]\n"
               ,  maxval, cube, center, threeTwo
               ,  alwaysBar, mass,  vec_d->n_ivps
               )

         ;  if (maxDensity && (vec_d->n_ivps > maxDensity))
            {
               int   y

            ;  hintList[0].val   =  (  threeTwo
                                    /  threeTwoWeight
                                    )

            ;  hintList[1].val   =  (  center
                                    /  centerWeight
                                    )

            ;  hintList[2].val   =  (  cube
                                    /  cubeWeight
                                    )

            ;  hintList[3].val   =  (  maxval
                                    /  maxValWeight1
                                    )

            ;  hintList[4].val   =  (  maxval
                                    /  maxValWeight2
                                    )

            ;  for (y=0;y<5;y++)
               {  hintList[y].n_gt  =  mcxVectorCountGqBar
                                       (vec_d, hintList[y].val)
               ;  hintList[y].idx   =  y
            ;  }

            ;  if (mcxTrackNonemaPruning)
               {  fprintf
                  (  mcxTrackStreamNonema->fp
                  ,  "[%s] hints, input size, size after blind prune\n"
                     "%8d| %8d| %8d| %8d| %8d| %8d -> %d\n"
                  ,  LOC_TRACK_PRUNING
                  ,  hintList[0].n_gt
                  ,  hintList[1].n_gt
                  ,  hintList[2].n_gt
                  ,  hintList[3].n_gt
                  ,  hintList[4].n_gt
                  ,  n_full
                  ,  vec_d->n_ivps
                  )
               ;  fprintf
                  (  mcxTrackStreamNonema->fp
                  ,  "%.6f| %.6f| %.6f| %.6f| %.6f|       %.6f\n"
                  ,  hintList[0].val
                  ,  hintList[1].val
                  ,  hintList[2].val
                  ,  hintList[3].val
                  ,  hintList[4].val
                  ,  alwaysBar
                  )
            ;  }
                              /*
                              // Sort hints according to how much they leave.
                              */

            ;  qsort(hintList, 5, sizeof(hint), hintCmp)

                              /*
                              // Try to find the best hint below maxDensity.
                              */

            ;  {
                  int l = -1
               ;  int x = 0

               ;  while(x < 5 && hintList[x].n_gt <= maxDensity)
                  l     =  x++

                              /*
                              // Case: all hints leave less than maxDensity.
                              */

               ;  if (l==4)
                  {
                     if (mcxTrackNonemaPruning)
                     fprintf
                     (  mcxTrackStreamNonema->fp
                     ,  "[%s] Severe hints: Using [%d, %.6f] pair\n"
                     ,  LOC_TRACK_PRUNING
                     ,  (hintList+4)->n_gt
                     ,  (hintList+4)->val
                     )

                  ;  mcxVectorSelectHighestWithHint
                     (  vec_d
                     ,  maxDensity
                     ,  (hintList+4)->val
                     ,  (hintList+4)->n_gt
                     )

                  ;  n_bestHint  =  (hintList+4)->n_gt
                  ;  hintScores[(hintList+4)->idx]++
               ;  }

                              /*
                              // Case: all hints leave more than maxDensity.
                              // Prune the one that is most severe.
                              */

                  else if (l<0)
                  {
                  ;  mcxVectorSelectGqBar(vec_d, (hintList+0)->val)

                  ;  if (mcxTrackNonemaPruning) fprintf
                     (  mcxTrackStreamNonema->fp
                     ,  "[%s] Loose hints: Pruning on [%d, %.6f] pair\n"
                     ,  LOC_TRACK_PRUNING
                     ,  (hintList+0)->n_gt
                     ,  (hintList+0)->val
                     )
                  ;  mcxVectorSelectHighest(vec_d, maxDensity)

                  ;  n_bestHint  =  (hintList+0)->n_gt

                  ;  if (n_bestHint < 2*maxDensity)
                     hintScores[(hintList+0)->idx]++
               ;  }

                  else
                  {  
                     int   n_u   =  (hintList+l+1)->n_gt
                  ;  int   n_l   =  (hintList+l)->n_gt

                  ;  if (mcxTrackNonemaPruning) fprintf
                     (  mcxTrackStreamNonema->fp
                     ,  "[%s] Both lower and upper hint exist:\n"
                        "[%d, %.6f] [%d, %.6f]\n"
                     ,  LOC_TRACK_PRUNING
                     ,  n_l
                     ,  (hintList+l)->val
                     ,  n_u
                     ,  (hintList+l+1)->val
                     )

                  ;  if (abs(n_u - maxDensity) <= abs(maxDensity-n_l))
                     {  
                        if (mcxTrackNonemaPruning)
                           fprintf
                           (  mcxTrackStreamNonema->fp
                           ,  "[%s] Choosing upper\n"
                           ,  LOC_TRACK_PRUNING
                           )

                     ;  mcxVectorSelectHighestWithHint
                        (  vec_d
                        ,  maxDensity
                        , (hintList+l+1)->val
                        , (hintList+l+1)->n_gt
                        )

                     ;  n_bestHint  =  (hintList+l+1)->n_gt
                     ;  hintScores[(hintList+l+1)->idx]++
                  ;  }
                     /* end upper lower hint is best                     */

                     else
                     {
                        if (mcxTrackNonemaPruning)
                           fprintf
                           (  mcxTrackStreamNonema->fp
                           ,  "[%s] Choosing lower\n"
                           ,  LOC_TRACK_PRUNING
                           )

                     ;  mcxVectorSelectGqBar(vec_d, (hintList+l+1)->val)
                     ;  mcxVectorSelectHighestWithHint
                        (  vec_d
                        ,  maxDensity
                        , (hintList+l)->val
                        , (hintList+l)->n_gt
                        )

                     ;  n_bestHint  =  (hintList+l)->n_gt
                     ;  hintScores[(hintList+l)->idx]++
                  ;  }

                    /*
                     *  End case lower hint is best
                    */

                  }

                 /*
                  *  End case there are two hints.
                 */

               }

              /*
               *  End of block where hints are evaluated.
              */

         ;  if (stats->dbAllocated)
            mcxDistrStoreValue(stats->hDb, (float) n_bestHint )

         ;  }

           /*
            *  end case n_full > maxDensity
           */

         ;  if (stats->dbAllocated)
            mcxDistrStoreValue(stats->pDb, (float) n_pruned )
      ;  }

      ;  maxval      =  mcxVectorMaxValue(vec_d)
      ;  threeTwo    =  (float) pow((double)mcxVectorPowSum(vec_d, 1.5), 2.0)

/*    should not do this by default in dense pruning, perhaps also not
 *    by default in plain pruning.
 *    restructure this stuff.
*/
      ;  alwaysBar   =  (  threeTwo
                        *  (float) pow
                           (  1.01 - reduce
                           ,  2.0
                           )
                        *  (float) pow
                           (  1.01 - (threeTwo / maxval)
                           ,  2.0
                           )
                        /  alwaysBarWeight
                        )

      ;  mcxVectorSelectGqBar(vec_d, alwaysBar)

      ;  if (stats->dbAllocated)
         {  mass              =  mcxVectorSum(vec_d)
         ;  mcxDistrStoreValue(stats->mDb, mass )
      ;  }

      ;  mcxVectorNormalize(vec_d)

      ;  vectorInhomogeneity     =  (maxval-threeTwo) * vec_d->n_ivps

      ;  if (vectorInhomogeneity > matrixInhomogeneity)
         matrixInhomogeneity = vectorInhomogeneity
   ;  }

   ;  if (mclProgress)
      {  if (mclVerbosity)
         fprintf(stdout, "\n")
      ;  else
         fprintf(stdout, " %2.2f\n", matrixInhomogeneity)
   ;  }

   ;  mcxTrackNonemaPruning =  mainTrackPruning

   ;  mcxIvpStorageFreeIfNot(0)
   ;  mcxIvpFree(&maxDensityIvp)

   ;  stats->inhomogeneity =  matrixInhomogeneity
   ;  return mx_d
;  }


mcxComposeStats* mcxComposeStatsNew
(  
   int   dbSize
)  
   {  
      mcxComposeStats* stats  =  (mcxComposeStats*) rqAlloc
                                 (  
                                    sizeof(mcxComposeStats)
                                 ,  EXIT_ON_FAIL
                                 )

   ;  stats->vDb              =  dbSize ? mcxDistrNew(dbSize) : NULL
   ;  stats->pDb              =  dbSize ? mcxDistrNew(dbSize) : NULL
   ;  stats->hDb              =  dbSize ? mcxDistrNew(dbSize) : NULL
   ;  stats->mDb              =  dbSize ? mcxDistrNew(dbSize) : NULL

   ;  stats->dbAllocated      =  dbSize ? 1 : 0

   ;  if (  dbSize &&
            (!stats->vDb || !stats->pDb || !stats->hDb || !stats->mDb )
         )
      {  fprintf
         (  stderr
         ,  "[mcxComposeStatsNew] could not allocate all four distributions"
            " (each of size %d)\n"
         ,  dbSize
         )
      ;  exit(1)
   ;  }

   ;  stats->inhomogeneity    =  0.0
   ;  stats->n_selectHighest  =  0
   ;  stats->massNx           =  mclMassNx
   ;  stats->massNy           =  mclMassNy

   ;  (stats->dbList)[0]      =  stats->mDb
   ;  (stats->dbList)[1]      =  stats->vDb
   ;  (stats->dbList)[2]      =  stats->pDb
   ;  (stats->dbList)[3]      =  stats->hDb

   ;  return stats
;  }


void mcxComposeStatsFree
(
   mcxComposeStats* stats
)  
   {  
      mcxDistrFree(&(stats->vDb))
   ;  mcxDistrFree(&(stats->pDb))
   ;  mcxDistrFree(&(stats->mDb))
   ;  mcxDistrFree(&(stats->hDb))
   ;  rqFree(stats)
;  }


void mcxComposeStatsReset
(  mcxComposeStats* stats
)  
   {  
      if (stats->vDb)
      mcxDistrClear(stats->vDb)

   ;  if (stats->pDb)
      mcxDistrClear(stats->pDb)

   ;  if (stats->mDb)
      mcxDistrClear(stats->mDb)

   ;  if (stats->hDb)
      mcxDistrClear(stats->hDb)

   ;  stats->inhomogeneity    =  0.0
   ;  stats->n_selectHighest  =  0
;  }


void mcxComposeStatsPrint
(  
   mcxComposeStats*  stats
,  FILE*             fp
)
   {  
      mcxDistr**     dbList  =  stats->dbList
   ;  mcxDistr*      db
   ;  float          av, dv
   ;  int            i

   ;  for(i=0;i<4;i++)
      {  
         db    =  dbList[i]

      ;  av    =  mcxDistrGetAverage(db)
      ;  dv    =  mcxDistrGetDeviation(db)

      ;  if (db == stats->mDb)
         fprintf(fp, "%6.2f|%-6d", av, stats->hDb->N)
      ;  else
         fprintf(fp, "%6.0f,%-6.0f", av, dv)
   ;  }

   ;  fprintf(fp, " %6.2f|", stats->inhomogeneity)
;  }



/*
// compose.c            MCL specific compose
*/

#include <math.h>
#include <limits.h>
#include <float.h>
#include <pthread.h>

#include "nonema/compose.h"
#include "nonema/ivp.h"
#include "nonema/vector.h"
#include "nonema/iface.h"

#include "mcl/compose.h"
#include "mcl/params.h"

#include "intalg/ilist.h"

#include "util/alloc.h"
#include "util/iface.h"
#include "util/heap.h"
#include "util/minmax.h"


static const char* tags    =  "0123456789@";

static int   levels[]
=  {
      8000
   ,  5000
   ,  3000
   ,  2000
   ,  1250

   ,  800
   ,  500
   ,  300
   ,  200
   ,  125

   ,  80
   ,  50
   ,  30
   ,  20
   ,  12
   ,  -1
   }  ;     /* ~ magstep 5sqrt10 */


int n_levels   =  sizeof(levels)/sizeof(int) ;

static void levelAccount
(  
   int   size
,  char  levelType
)  ;


void mcxNewFlowVector_thread
(
   void* arg
)  ;


static struct
{
   mcxHeap*       worstXprune
;  mcxHeap*       worstYprune
;  mcxHeap*       worstXselect
;  mcxHeap*       worstYselect

;  Ilist*         ilLevelsC
;  Ilist*         ilLevelsP

;  float          sum_prune_all
;  float          sum_select_all

;  float          inhomogeneity

;  int            n_selects
;  int            n_recoveries
;  int            n_vectors
;
}  reg
   =  
   {  NULL, NULL, NULL, NULL
   ,  NULL, NULL
   ,  0.0,  0.0
   ,  0.0
   ,  0,    0,    0  
   }  ;
  /*  Registry for statistics  */


static pthread_mutex_t reg_mutex = PTHREAD_MUTEX_INITIALIZER;


void mcxNewFlowVector
(
   const mcxMatrix*  mx
,  const mcxVector*  vec_s                      /* src                     */
,  mcxVector*        vec_d                      /* dst                     */
,  int               maxDensity
,  float             precision
,  mcxVector*        tmpVec
,  mcxVector*        ivpVec
)  ;


typedef struct
{
   int               id
;  int               start
;  int               end
;  mcxMatrix*        mxs
;  mcxMatrix*        mxd
;  int               maxDensity
;  float             precision
;  mcxVector*        tmpVec
;  mcxVector*        ivpVec
;
}  mcxNewFlowVector_arg
   ;

pthread_t            *threads_expand;
pthread_attr_t       pthread_custom_attr;


static void vecMeasure
(
   mcxVector*        vec
,  float             *maxval
,  float             *center
)  ;


mcxComposeParam* mcxComposeParamNew
(  void
)  
   {  
      mcxComposeParam *cpParam      =     (mcxComposeParam*) rqAlloc
                                          (  sizeof(mcxComposeParam)
                                          ,  EXIT_ON_FAIL
                                          )

   ;  cpParam->maxDensity           =     mclDefaultMaxDensity
   ;  cpParam->precision            =     (float)
                                          pow(10.0,-mclDefaultPrecisionExponent)
   ;  cpParam->precisionExponent    =     mclDefaultPrecisionExponent
   ;  return cpParam
;  }


void mcxNewFlowVector_thread
(
   void* arg
)
   {
      mcxNewFlowVector_arg *p       =  (mcxNewFlowVector_arg *) arg

   ;  int                  maxDensity= p->maxDensity
   ;  float                precision=  p->precision
   ;  mcxVector*           tmpVec   =  p->tmpVec
   ;  mcxVector*           ivpVec   =  p->ivpVec
   ;  const mcxMatrix*     mxs      =  p->mxs
   ;  mcxMatrix*           mxd      =  p->mxd

   ;  const mcxVector*     srcVec   =  mxs->vectors + p->start
   ;  const mcxVector*     srcMax   =  mxs->vectors + p->end
   ;  mcxVector*           dstVec   =  mxd->vectors + p->start
   ;  mcxVector*           dstMax   =  mxd->vectors + p->end
;  }

/*
 *    The threaded version needs to create a separate ivpVec and tmpVec
 *    for each thread. The same ivpVec and tmpVec can then be used
 *    for each call to the threaded mcxNewFlowVector.
 *
 *    The threaded should eventually implement the choice of making a separate
 *    copy of mx for each thread (or sharing the same instance),
 *    but for now either way is fine.
 *
 *    In the threaded version a mutex lock needs to be created for
 *    the block in which reg is updated.
*/

void mcxNewFlowVector
(
   const mcxMatrix*  mx
,  const mcxVector*  vec_s                      /* src                     */
,  mcxVector*        vec_d                      /* dst                     */
,  int               maxDensity
,  float             precision
,  mcxVector*        tmpVec
,  mcxVector*        ivpVec
)
   {
      int            rg_n_compose   =  0
   ;  int            rg_n_prune     =  0

   ;  int            rg_b_recover   =  0

   ;  float          rg_mass_prune  =  0.0
   ;  float          rg_mass_select =  0.0

   ;  float          rg_sbar        =  -1.0     /*    select bar           */
   ;  float          rg_rbar        =  -1.0     /*    recovery bar         */

   ;  float          mass_final     =  1.0
                     
   ;  float          maxval, center, vectorInhomogeneity

   ;  if (mclDense)
      mcxMatrixVectorDenseCompose
      (  mx
      ,  vec_s
      ,  vec_d
      )
   ;  else
      mcxMatrixVectorCompose
      (  mx
      ,  vec_s
      ,  vec_d
      ,  ivpVec
      )

   ;  rg_n_compose   =  vec_d->n_ivps ? vec_d->n_ivps : maxDensity

   ;  if (mclDense)
      {
         if (precision)
         {  
            rg_mass_prune  =  mcxVectorSelectGqBar (vec_d, precision)
         ;  rg_n_prune     =  vec_d->n_ivps

         ;  mass_final     =  rg_mass_prune
      ;  }

      ;  vecMeasure(vec_d, &maxval, &center)
   ;  }

     /*
      *     yet again improved pruning and kselect.
     */

      else
      {
         float    cut_prune

      ;  {  if (mclRecover)

            /* mcxVectorInstantiate(tmpVec, vec_d->n_ivps, vec_d->ivps) */
            memcpy(tmpVec->ivps, vec_d->ivps, vec_d->n_ivps * sizeof(mcxIvp))
         ;  tmpVec->n_ivps = vec_d->n_ivps
      ;  }

      ;  vecMeasure(vec_d, &maxval, &center)

      ;  cut_prune      =  (1/mclCutCof)*center*pow(center/maxval,mclCutExp)
      ;  rg_mass_prune  =  mcxVectorSelectGqBar(vec_d, cut_prune)
      ;  rg_n_prune     =  vec_d->n_ivps

      ;  if (rg_n_prune >= 2*maxDensity)
         rg_sbar
         =  mcxVectorKBar
            (  vec_d
            ,  maxDensity
            ,  FLT_MAX
            ,  NULL
            ,  KBAR_SELECT_LARGE
            )
      ;  else if (rg_n_prune > maxDensity)
         rg_sbar
         =  mcxVectorKBar
            (  vec_d
            ,  vec_d->n_ivps - maxDensity+1
            ,  -FLT_MAX
            ,  NULL
            ,  KBAR_SELECT_SMALL
            )
      ;  else if
         (rg_n_prune < maxDensity && rg_mass_prune < mclThr && mclRecover)
         {
            mcxVectorInstantiate(vec_d, tmpVec->n_ivps, tmpVec->ivps)
         ;  rg_b_recover++

         ;  if (vec_d->n_ivps > maxDensity)
            rg_rbar
            =  mcxVectorKBar
            (  vec_d
            ,  maxDensity - rg_n_prune
            ,  cut_prune
            ,  NULL
            ,  KBAR_SELECT_LARGE
            )
      ;  }
         else
         {
           /*
            *     rg_n_prune < maxDensity &&
            *     rg_mass_prune >= mclThr || !mclRecover
           */
      ;  }


      ;  if (rg_sbar >= 0.0)
         {  
            rg_mass_select =  mcxVectorSelectGqBar(vec_d, rg_sbar)
         ;  mass_final     =  rg_mass_select
      ;  }

         else if (rg_rbar >= 0.0)
         mass_final        =  mcxVectorSelectGqBar(vec_d, rg_rbar)

      ;  else
         mass_final        =  rg_mass_prune
   ;  }


   ;  mcxVectorScale(vec_d, mass_final)
   ;  vectorInhomogeneity  =  (maxval-center) * vec_d->n_ivps
   ;


     /*
     /*  We need a mutex lock for the block below for variable reg.
     */

      {
         pthread_mutex_lock(&reg_mutex)

      ;  if (vectorInhomogeneity > reg.inhomogeneity)
         reg.inhomogeneity = vectorInhomogeneity

      ;  if (mclVerbosity)
         {
            levelAccount(rg_n_compose, 'c')
         ;  levelAccount(rg_n_prune, 'p')

         ;  mcxHeapInsert(reg.worstXprune, &rg_mass_prune)
         ;  mcxHeapInsert(reg.worstYprune, &rg_mass_prune)
         ;  reg.sum_prune_all +=  rg_mass_prune

         ;  if (rg_sbar >= 0.0)
            {  reg.n_selects++
            ;  mcxHeapInsert(reg.worstXselect, &rg_mass_select)
            ;  mcxHeapInsert(reg.worstYselect, &rg_mass_select)
            ;  reg.sum_select_all    +=  rg_mass_select
         ;  }

            if (rg_b_recover)
            reg.n_recoveries++
      ;  }

         if (mclProgress)
         {
            reg.n_vectors++

         ;  if (reg.n_vectors % mclProgress == 0)
            fwrite(".", sizeof(char), 1, stdout)
         ,  fflush(stdout)
      ;  }

         pthread_mutex_unlock(&reg_mutex)
   ;  }

;  }


/*
 *    There are a lot of parameters that are now global/static in scope.
 *    mclDense, mclCutCof, mclCutExp, mclThr, mclProgress, mclRecover ..
 *    Are these best packaged together, or is it not a big deal?
 *    Note that none of them is accessed more than once or twice or so.
 *    I think it's best to leave it as it is for now. Maybe it can
 *    be changed later.
 *
 *    The package for mcxNewFlowVector needs to create a copy of tmpVec and a
 *    copy of ivpStorage (replacing ivpStorage in nonema/matrix.c) for each
 *    thread. The same copies can be used in all calls to mcxNewFlowVector
 *    that are local to the thread.
*/

mcxMatrix* mcxFlowExpand
(  
   const mcxMatrix*        mx
,  mcxComposeParam*        param
,  mcxComposeStats*        stats
)
   {
      mcxMatrix*           mx_d
   ;  mcxVector*           tmpVec         =  mcxVectorCreate(mx->N_rows)  
   ;  mcxVector*           ivpVec         =  mcxVectorCreate(mx->N_rows+1)  
   ;  int                  col            =  0

   ;  int                  maxDensity     =  param->maxDensity
   ;  float                precision      =  param->precision

   ;  if (mx->N_cols != mx->N_rows)
         fprintf(stderr, "[mcxFlowExpand PBD] matrix not square\n")
      ,  exit(1)

   ;  mx_d                 =  mcxMatrixAllocZero(mx->N_rows, mx->N_cols)

   ;  mcxComposeStatsReset(stats)
   ;

     /*
     /*  Initialization of the registry. Here information is stored
     /*  which is eventually used to compute a bunch of statistics.
     /*  Probably nobody cares about this stuff, but I want it in.
     */

      {  
         reg.worstXprune   =  mcxHeapNew
                              (stats->nx,sizeof(float),fltCmp,MAX_HEAP)
      ;  reg.worstYprune   =  mcxHeapNew
                              (stats->ny,sizeof(float),fltCmp,MAX_HEAP)
      ;  reg.worstXselect  =  mcxHeapNew
                              (stats->nx,sizeof(float),fltCmp,MAX_HEAP)
      ;  reg.worstYselect  =  mcxHeapNew
                              (stats->ny,sizeof(float),fltCmp,MAX_HEAP)

      ;  reg.sum_select_all=  0.0
      ;  reg.sum_prune_all =  0.0
      ;  reg.inhomogeneity =  0.0

      ;  reg.n_selects     =  0
      ;  reg.n_recoveries  =  0
      ;  reg.n_vectors     =  0

      ;  reg.ilLevelsC     =  ilInstantiate(reg.ilLevelsC,n_levels, NULL, 0)
      ;  reg.ilLevelsP     =  ilInstantiate(reg.ilLevelsP, n_levels, NULL, 0)
   ;  }


  /*
   *  This loop needs to be threaded, and each thread needs to have
   *  it's own copy of tmpVec and ivpVec. This means that the declarations
   *     mcxVector*           tmpVec         =  mcxVectorCreate(mx->N_rows)  
   *     mcxVector*           ivpVec         =  mcxVectorCreate(mx->N_rows+1)  
   *  (see above) need to be suitably cloned for each thread package separately.
  */

   ;  for (col=0;col<mx->N_cols;col++)
      {
         mcxVector*  vec_d          =  mx_d->vectors + col

      ;  mcxNewFlowVector
         (  mx
         ,  mx->vectors+col
         ,  mx_d->vectors+col
         ,  maxDensity
         ,  precision
         ,  tmpVec
         ,  ivpVec
         )
   ;  }


     /*
     /*  At this point all threads should be finished.
     /*  This follows just from using pthread_join if I understand correctly.
     */

   ;  if (mclProgress)
      {  if (mclVerbosity)
         fprintf(stdout, "\n")
      ;  else
         fprintf(stdout, " %2.2f\n", reg.inhomogeneity)
   ;  }


     /*
     /*  All but the level accounting part of the registry.
     /*  Transferral of information from registry to stats.
     */

   ;  {  
         int   x, y

      ;  float sumx_prune     =  0.0
      ;  float sumy_prune     =  0.0

      ;  float sumx_select    =  0.0
      ;  float sumy_select    =  0.0

      ;  if (reg.worstXprune->n_inserted)
         {
            float*   flp      =  (float *) reg.worstXprune->base  

         ;  for (x=0;x<reg.worstXprune->n_inserted;x++)
            sumx_prune += *(flp+x)

         ;  stats->mass_prune_nx    =  sumx_prune/reg.worstXprune->n_inserted
      ;  }

      ;  if (reg.worstYprune->n_inserted)
         {
            float*   flp      =  (float *) reg.worstYprune->base  

         ;  for (y=0;y<reg.worstYprune->n_inserted;y++)
            sumy_prune += *(flp+y)

         ;  stats->mass_prune_ny    =  sumy_prune/reg.worstYprune->n_inserted
      ;  }

         {
            float*   flp      =  (float *) reg.worstXselect->base

         ;  for (x=0;x<reg.worstXselect->n_inserted;x++)
            sumx_select += *(flp+x)
      ;  }

         {
            float*   flp      =  (float *) reg.worstYselect->base

         ;  for (y=0;y<reg.worstYselect->n_inserted;y++)
            sumy_select += *(flp+y)
      ;  }

      ;  stats->mass_prune_all   =  reg.sum_prune_all/mx->N_cols


      ;  if (reg.n_selects)
         {  
            stats->n_selects        =  reg.n_selects
         ;  stats->mass_select_all  =  reg.sum_select_all/reg.n_selects
         ;  stats->mass_select_ny   =  sumy_select/reg.worstYselect->n_inserted
         ;  stats->mass_select_nx   =  sumx_select/reg.worstXselect->n_inserted
      ;  }

      ;  mcxHeapFree(&reg.worstXprune)
      ;  mcxHeapFree(&reg.worstYprune)
      ;  mcxHeapFree(&reg.worstXselect)
      ;  mcxHeapFree(&reg.worstYselect)

      ;  stats->n_recoveries     =  reg.n_recoveries
      ;  stats->inhomogeneity    =  reg.inhomogeneity
   ;  }


     /*
     /*  The level accounting part of the registry.
     /*  Transferral of information from registry to stats.
     */

   ;  {
         int   x, y
      ;  int   n_levels_p        =  reg.ilLevelsP->n
      ;  int   n_levels_c        =  reg.ilLevelsC->n

      ;  char *cString           =  (char*) rqAlloc(n_levels_c+1, EXIT_ON_FAIL)
      ;  char *pString           =  (char*) rqAlloc(n_levels_p+1, EXIT_ON_FAIL)
      
      ;  pString[n_levels_p-1]   =  '\0'
      ;  cString[n_levels_c-1]   =  '\0'

      ;  ilAccumulate(reg.ilLevelsC)
      ;  ilAccumulate(reg.ilLevelsP)

      ;  for (x=0;x<n_levels_c-1;x++)
         {  int   n              =  *(reg.ilLevelsC->list+x)
         ;  cString[x]           =     n == 0
                                    ?  '_'
                                    :  tags[((1000*n / (mx->N_cols))+50) / 100]
      ;  }

      ;  for (x=0;x<n_levels_p-1;x++)
         {  int   n              =  *(reg.ilLevelsP->list+x)
         ;  pString[x]           =     n == 0
                                    ?  '_'
                                    :  tags[((1000*n / (mx->N_cols))+50) / 100]
      ;  }

      ;  stats->levels_compose   =  mcxTxtNew(cString)
      ;  stats->levels_prune     =  mcxTxtNew(pString)
      ;  rqFree(cString)
      ;  rqFree(pString)
   ;  }

   ;  mcxVectorFree(&tmpVec)
   ;  mcxVectorFree(&ivpVec)

   ;  return mx_d
;  }


mcxComposeStats* mcxComposeStatsNew
(  
   int   nx
,  int   ny
)  
   {  
      mcxComposeStats* stats  =  (mcxComposeStats*) rqAlloc
                                 (  
                                    sizeof(mcxComposeStats)
                                 ,  EXIT_ON_FAIL
                                 )

   ;  stats->nx               =  nx
   ;  stats->ny               =  ny

   ;  stats->inhomogeneity    =  0.0
   ;  stats->n_selects        =  0
   ;  stats->n_recoveries     =  0

   ;  stats->mass_select_nx   =  0.0
   ;  stats->mass_select_ny   =  0.0
   ;  stats->mass_select_all  =  0.0

   ;  stats->mass_prune_nx    =  0.0
   ;  stats->mass_prune_ny    =  0.0
   ;  stats->mass_prune_all   =  0.0

   ;  stats->levels_compose   =  NULL
   ;  stats->levels_prune     =  NULL

   ;  return stats
;  }


void mcxComposeStatsFree
(
   mcxComposeStats* stats
)  
   {  
      mcxTxtFree(&(stats->levels_compose))
   ;  mcxTxtFree(&(stats->levels_prune))
   ;  rqFree(stats)
;  }


void mcxComposeStatsReset
(  mcxComposeStats* stats
)  
   {  
      stats->inhomogeneity       =  0.0
   ;  stats->n_selects           =  0
   ;  stats->n_recoveries        =  0

   ;  stats->mass_prune_nx       =  0.0
   ;  stats->mass_prune_ny       =  0.0
   ;  stats->mass_prune_all      =  0.0

   ;  stats->mass_select_nx      =  0.0
   ;  stats->mass_select_ny      =  0.0
   ;  stats->mass_select_all     =  0.0

   ;  mcxTxtFree(&(stats->levels_compose))
   ;  mcxTxtFree(&(stats->levels_prune))
;  }


void mcxComposeStatsPrint
(  
   mcxComposeStats*  stats
,  FILE*             fp
)
   {
      fprintf
      (  fp
      ,  "%3d%3d%3d %3d%3d%3d %s %s %-7d %-7d "
      ,  (int) (100.0*stats->mass_prune_all)
      ,  (int) (100.0*stats->mass_prune_ny)
      ,  (int) (100.0*stats->mass_prune_nx)
      ,  (int) (100.0*stats->mass_select_all)
      ,  (int) (100.0*stats->mass_select_ny)
      ,  (int) (100.0*stats->mass_select_nx)
      ,  stats->levels_compose->str
      ,  stats->levels_prune->str
      ,  stats->n_recoveries
      ,  stats->n_selects
      )
;  }


/* we should have a mutex on reg */

static void levelAccount
(  
   int   size
,  char  levelType
)
   {  
      int   i  =  0

   ;  while (size < levels[i] && i<n_levels)
      i++

   ;  if (levelType == 'c')
      (*(reg.ilLevelsC->list+i))++

   ;  else if (levelType == 'p')
      (*(reg.ilLevelsP->list+i))++
;  }


static void vecMeasure
(  
   mcxVector*  vec
,  float       *maxval
,  float       *center
)  
   {
      mcxIvp*  ivp      =  vec->ivps
   ;  int      n_ivps   =  vec->n_ivps
   ;  float    m        =  0.0
   ;  float    c        =  0.0

   ;  while (--n_ivps >= 0)
      {  
         float val      =  (ivp++)->val

      ;  c += val * val

      ;  if (val > m)
         m = val
   ;  }

   ;  *maxval           =  m
   ;  *center           =  c
;  }


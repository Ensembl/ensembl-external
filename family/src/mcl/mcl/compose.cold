/*
// compose.c            MCL specific compose
*/

#include <math.h>

#include "linalg/compose.h"
#include "linalg/ivp.h"
#include "linalg/track.h"

#include "mcl/compose.h"
#include "util/minmax.h"


extern   int      B_adjustAdjust;
extern   double   shiftAdjust;
extern   double   maxAdjust;

static const char* TRACK1 = "trackPruning mclComposeMatrix";

MclComposeParam* mclComposeParamNew
(void
)  {  MclComposeParam* cpParam = malloc(sizeof(MclComposeParam))
   ;  if (!cpParam)
      {  fprintf(stderr, "mclComposeParamNew: failed to allocate MclComposeParam object\n")
      ;  exit(1)
   ;  }
   ;  cpParam->maxDensity             =     20
   ;  cpParam->B_onlyPrune            =     0
   ;  cpParam->B_autoPrune            =     1
   ;  cpParam->B_adjustPrune          =     0
   ;  cpParam->adjustFactor           =     0.0
   ;  cpParam->prunePow1              =     1.0
   ;  cpParam->prunePow2              =     1.0
   ;  cpParam->pruneCof1              =     1.0
   ;  cpParam->pruneCof2              =     1.0
   ;  cpParam->precision              =     pow(10,-6)
   ;  cpParam->precisionExponent      =     6
   ;  cpParam->iterand                =     1

   ;  return cpParam
;  }



Matrix* mclComposeMatrix
(  const Matrix*           mx1
,  const Matrix*           mx2
,  MclComposeParam*        param
,  MclComposeStats*        stats
)
   {  Matrix*              mx_d
   ;  int                  mx2col  =  0
   ;  IvpBuf               barBuf

   ;  int                  maxDensity        =  param->maxDensity
   ;  Ivp*                 maxDensityIvp     =  ivpCreate(maxDensity, 0.0)

   ;  double               iterand           =  (double) param->iterand
   ;  double               adjustFactor      =  param->adjustFactor
   ;  double               precision         =  param->precision
   ;  double               pruneCof1         =  param->pruneCof1
   ;  double               pruneCof2         =  param->pruneCof2
   ;  double               prunePow1         =  param->prunePow1
   ;  double               prunePow2         =  param->prunePow2

   ;  double               matrixInhomogeneity = 0
   ;  Distr*               barDb             =  stats->barDb
   ;  Distr*               nDb               =  stats->nDb

   ;  int                  mainTrackPruning  =  trackPruning

   ;  ivpBufInit(&barBuf,  20, 1.66)
   ;  mclComposeStatsReset(stats)
                                       /* the code in the following line   */
                                       /* affects mclMatrixVectorCompose   */
   ;  ivpBufAllocated((mx2->vector_range)+1)

   ;  if (mx1->n_vectors != mx2->vector_range)
      {  fprintf(stderr, "Imcompatible size matrices for compose operation\n")
      ;  exit(1)
   ;  }

   ;  if (B_adjustAdjust)
      {  adjustFactor      =     (double) iterand + shiftAdjust
      ;  adjustFactor      =     mind(adjustFactor, maxAdjust)
      ;  fprintf(stderr, "!!!!   adjusting with factor %f\n", adjustFactor)
   ;  }

   ;  mx_d = mclMatrixAllocZero(mx1->vector_range, mx2->n_vectors)
   ;  if (!mx_d) exit(1)

   ;  if (mainTrackPruning)
         fprintf
         (  stderr
         ,  "____ [%s] at start\n"
         ,  TRACK1
         )

   ;  for (mx2col=0;mx2col<mx2->n_vectors;mx2col++)

      {  Vector*  vec_d    =  mx_d->vectors + mx2col
      ;  double   maxval, cube, center, threeTwo

      ;  trackPruning      =      mainTrackPruning
                              &&  (((mx2col+1)%trackPruningGranularity)==0)

      ;  mclMatrixVectorCompose
         (  mx2->vectors + mx2col
         ,  mx1
         ,  vec_d
         ,  NULL        /* default setting: normal 'addTo' function */
         )

      ;  if (trackPruning)
            fprintf
            (  stderr
            ,  "\n[%s] vector %d, size %d\n"
            ,  TRACK1, mx2col, vec_d->n_ivps
            )
/*
//    so far normal matrix multiplication.
//    In the following some options are implemented which enable
//    different ways of pruning the vector just computed, vec_d.
*/
      ;  maxval   =  mclVectorMaxValue(vec_d)
      ;  cube     =  sqrt(mclVectorPowSum(vec_d, 3.0))
      ;  center   =  mclVectorPowSum(vec_d, 2.0)
      ;  threeTwo =  pow(mclVectorPowSum(vec_d, 1.5), 2.0)


/*    full matrix computation
*/
      ;  if (  !maxDensity )
         {  if (precision)
            {  mclVectorSelectGeqBar (vec_d, precision)
            ;  if (barDb != NULL) distrStoreValue(barDb, (float) vec_d->n_ivps )
         ;  }
      ;  }

         else  if (1)
         {  int                  n_vec
         ;  double               idelta, jdelta
         ;  double               alwaysBar, hint1, hint2, hint3, hint4, hint5

         ;  n_vec             =  vec_d->n_ivps ? vec_d->n_ivps : maxDensity

         ;  idelta            =  maxDensity < n_vec
                                 ?  (  (double) 1.0/maxDensity
                                    -  (double) 1.0/n_vec
                                    )
                                 :  (double) 1.0/maxDensity


         ;  jdelta            =  (double) 1.0/maxDensity

         ;  alwaysBar         =  (  threeTwo
                                 *  idelta
                                 )

         ;  alwaysBar         =  (  threeTwo
                                 *  pow
                                    (  1.0 - ((double) maxDensity / n_vec)
                                    ,  1.0
                                    )
                                 *  pow
                                    (  1.0 - maxval + threeTwo
                                    ,  1.0
                                    )
                                 /  8.0
                                 )

         ;  hint1             =  (  threeTwo
                                 /  8.0
                                 )

         ;  hint2             =  (  center
                                 /  8.0
                                 )

         ;  hint3             =  (  cube
                                 /  8.0
                                 )

         ;  hint4             =  (  maxval
                                 /  16.0
                                 )

         ;  hint5             =  (  maxval
                                 /  32.0
                                 )

         ;  mclVectorSelectGeqBar(vec_d, alwaysBar)

         ;  if (vec_d->n_ivps > maxDensity)
            {  int   n_hint1     =  mclVectorCountGeqBar(vec_d, hint1)
            ;  int   n_hint2     =  mclVectorCountGeqBar(vec_d, hint2)
            ;  int   n_hint3     =  mclVectorCountGeqBar(vec_d, hint3)
            ;  int   n_hint4     =  mclVectorCountGeqBar(vec_d, hint4)
            ;  int   n_hint5     =  mclVectorCountGeqBar(vec_d, hint5)

            ;  ivpBufStore(&barBuf, n_hint1, hint1)
            ;  ivpBufStore(&barBuf, n_hint2, hint2)
            ;  ivpBufStore(&barBuf, n_hint3, hint3)
            ;  ivpBufStore(&barBuf, n_hint4, hint4)
            ;  ivpBufStore(&barBuf, n_hint5, hint5)

            ;  if (trackPruning)
               {  fprintf
                  (  stderr
                  ,  "[%s] hints, input size, size after blind prune\n"
                     "%8d| %8d| %8d| %8d| %8d| %8d -> %d\n"
                  ,  TRACK1
                  ,  n_hint1, n_hint2, n_hint3, n_hint4, n_hint5
                  ,  n_vec
                  ,  vec_d->n_ivps
                  )
               ;  fprintf
                  (  stderr
                  ,  "%.6f| %.6f| %.6f| %.6f| %.6f|       %.6f\n"
                  ,  hint1, hint2, hint3, hint4, hint5, alwaysBar
                  )
            ;  }
                              /*
                              // Sort hints according to how much they leave.
                              */

            ;  qsort(barBuf.ivps, barBuf.n_ivps, sizeof(Ivp), ivpIdxCmp)

                              /*
                              // Try to find the best hint above maxDensity.
                              */

            ;  {  int u =  splitsearch
                           (  maxDensityIvp
                           ,  barBuf.ivps
                           ,  barBuf.n_ivps
                           ,  sizeof(Ivp)
                           ,  ivpIdxGeq
                           ,  1            /* return element right of split */
                           )

                              /*
                              // Try to find the best hint below maxDensity.
                              */

            ;     int l =  splitsearch
                           (  maxDensityIvp
                           ,  barBuf.ivps
                           ,  barBuf.n_ivps
                           ,  sizeof(Ivp)
                           ,  ivpIdxGeq
                           ,  0            /* return element left of split   */
                           )

                              /*
                              // Case: all hints leave less than maxDensity.
                              */

               ;  if (u<0)
                  {  
                  ;  if (trackPruning) fprintf
                     (  stderr
                     ,  "[%s] Severe hints: Using [%d, %.6f] pair\n"
                     ,  TRACK1
                     ,  (barBuf.ivps+barBuf.n_ivps-1)->idx
                     ,  (barBuf.ivps+barBuf.n_ivps-1)->val
                     )
                  ;  mclVectorSelectHighestWithHint
                     (  vec_d
                     ,  maxDensity
                     ,  (barBuf.ivps+barBuf.n_ivps-1)->val
                     ,  (barBuf.ivps+barBuf.n_ivps-1)->idx
                     )
               ;  }

                              /*
                              // Case: all hints leave more than maxDensity.
                              // Prune the one that is most severe.
                              */

                  else if (l<0)
                  {  
                  ;  mclVectorSelectGeqBar(vec_d, (barBuf.ivps+0)->val)

                  ;  if (trackPruning) fprintf
                     (  stderr
                     ,  "[%s] Loose hints: Pruning on [%d, %.6f] pair\n"
                     ,  TRACK1
                     ,  (barBuf.ivps+0)->idx
                     ,  (barBuf.ivps+0)->val
                     )
                  ;  mclVectorSelectHighest(vec_d, maxDensity)
               ;  }

                  else
                  {  
                     int   n_u   =  (barBuf.ivps+u)->idx
                  ;  int   n_l   =  (barBuf.ivps+l)->idx

                  ;  if (trackPruning) fprintf
                     (  stderr
                     ,  "[%s] Both lower and upper hint exist:\n"
                        "[%d, %.6f] [%d, %.6f]\n"
                     ,  TRACK1
                     ,  n_l
                     ,  (barBuf.ivps+l)->val
                     ,  n_u
                     ,  (barBuf.ivps+u)->val
                     )

                  ;  if (abs(n_u - maxDensity) <= abs(maxDensity-n_l))
                     {  
                        if (trackPruning)
                           fprintf
                           (  stderr
                           ,  "[%s] Choosing upper\n"
                           ,  TRACK1
                           )

                     ;  mclVectorSelectHighestWithHint
                        (  vec_d
                        ,  maxDensity
                        , (barBuf.ivps+u)->val
                        , (barBuf.ivps+u)->idx
                        )
                  ;  }

                     else
                     {
                        if (trackPruning)
                           fprintf
                           (  stderr
                           ,  "[%s] Choosing lower\n"
                           ,  TRACK1
                           )

                     ;  mclVectorSelectGeqBar(vec_d, (barBuf.ivps+u)->val)
                     ;  mclVectorSelectHighestWithHint
                        (  vec_d
                        ,  maxDensity
                        , (barBuf.ivps+l)->val
                        , (barBuf.ivps+l)->idx
                        )
                  ;  }
               ;  }
            ;  }

         ;  }

            else 
            {  if (trackPruning)
                  fprintf
                  (  stderr
                  ,  "[%s] blind prune [%.6f] went to %d\n"
                  ,  TRACK1,  alwaysBar,  vec_d->n_ivps
                  )
         ;  }
         ;  ivpBufReset(&barBuf, 0)
      ;  }

/*    normal approach: don't be a wise guy. not the default though.
*/
         else if  (maxDensity && !param->B_autoPrune && !param->B_onlyPrune)
         {  mclVectorSelectHighest(vec_d, maxDensity)
         ;  stats->n_selectHighest++
      ;  }

/*    special approach: prune with help of a bar, which depends on $center.
//    the way center is computed is specific to stochastic matrices,
//    though it could be generalized to arbitrary matrices.
//    [ center would then be (sum_{i} (x_i)^2) / (sum_{i} x_i) ]
//    This is the default.
*/
         else
         {
         ;  if  ( param->B_onlyPrune || (vec_d->n_ivps > maxDensity) )
            {  double threshold = (1.0 - adjustFactor*(maxval-center)) * pruneCof1 * pow(center, prunePow1)

            ;  if (nDb != NULL) distrStoreValue(nDb, (float) vec_d->n_ivps)

            ;  mclVectorSelectGeqBar(vec_d, threshold)
            ;  if (barDb != NULL) distrStoreValue(barDb, (float) vec_d->n_ivps )

            ;  if (!param->B_onlyPrune && vec_d->n_ivps > maxDensity)
               {  mclVectorSelectHighest (vec_d, maxDensity)
               ;  stats->n_selectHighest++
            ;  }
         ;  }
/*
//    indicates presence of small, left--over elements
*/
            else if  (   vec_d->n_ivps <= maxDensity
                     &&  (center > pow((double) (4+vec_d->n_ivps), -0.5))
                     )
            {  mclVectorSelectGeqBar (vec_d, pruneCof2 * pow(center, prunePow2))
         ;  }
      ;  }

      ;  matrixInhomogeneity = maxf (  (maxval-center) * vec_d->n_ivps
                                    ,  matrixInhomogeneity
                                    )
      ;  mclVectorNormalize(vec_d)
   ;  }

   ;  trackPruning =  mainTrackPruning

   ;  ivpBufFreeIfNot(0)
   ;  ivpBufFree(&barBuf)
   ;  ivpFree(&maxDensityIvp)

   ;  stats->inhomogeneity =  matrixInhomogeneity
   ;  param->iterand       += 1
   ;  return mx_d
;  }


MclComposeStats* mclComposeStatsNew
(void
)  {  MclComposeStats* stats = malloc(sizeof(MclComposeStats))
   ;  if (!stats)
      {  fprintf(stderr, "MclComposeStatsNew: failed to allocate MclComposeStats object\n")
      ;  exit(1)
   ;  }

   ;  stats->barDb            =  NULL
   ;  stats->nDb              =  NULL
   ;  stats->inhomogeneity    =  -1.0
   ;  stats->n_selectHighest  =  0

   ;  return stats
;  }

void mclComposeStatsReset
(MclComposeStats* stats
)  {  if (stats->barDb)
         distrClear(stats->barDb)
   ;  if (stats->nDb)
         distrClear(stats->nDb)
   ;  stats->inhomogeneity = -1.0
   ;  stats->n_selectHighest = 0
;  }

void mclComposeStatsPrint
(  const char*       when
,  int               iteration
,  MclComposeStats*  stats
,  FILE*             fp
)
   {  Distr*   db

   ;  {  float av, dv

      ;  db    =  stats->barDb
      ;  av    =  db->N ? distrGetAverage(db) : 0.0
      ;  dv    =  db->N ? distrGetDeviation(db) : 0.0

      ;  fprintf
         (  fp
         ,  "CPM> %s[%d], column inhom[%1.3f] select #[%d] thresholds #[%d] A[%.2f], D[%.2f]\n"
         ,  when
         ,  iteration
         ,  stats->inhomogeneity
         ,  stats->n_selectHighest
         ,  db->N
         ,  av
         ,  dv
         )
   ;  }

   ;  {  float    av, dv
      ;  db    = stats->nDb

      ;  av = db->N ? distrGetAverage(db) : 0.0
      ;  dv = db->N ? distrGetDeviation(db) : 0.0

      ;  fprintf
         (  fp
         ,  "initial vector sizes exceeding maxDensity: A[%.2f], D[%.2f]\n\n"
         ,  av
         ,  dv
         )
   ;  }

;  }



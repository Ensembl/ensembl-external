
\: zoem synopsis:
\:---------------
\: A  framework for  creating macro  languages, with  control operarors,
\: integer arithmetic,  stream character filtering,  associative arrays,
\: support  for   references,  inspection  and  diversions,   file  I/O,
\: anonymous keys, dictionary stacks, and more.


\: thoughts/todo
\:--------------
\: ref section for the d-group (?)
\:
\: mention 9-arg limit.
\: manuals dissected:  explain perhaps a little bit more.
\: ref point for white space munge rules.
\: let maketoc have an argument which is the reference for the toc.
\:
\: featuritis symptoms:
\:    \skim#1 (for level 0 expansion only)
\:          is there possibility + use for inside out expansion?
\:    \contains{x1}{x2} sets 1 if *x2 is substr of *x1
\:          this one probably crosses the Perl line.
\:    \protect (what can it do that meta can not?)



\ifdef{$device}{}{\def{$device}{html}}
\import{tut.zmm}

\set{"tut::html-title"}{Zoem User's Manual}
\set{"tut::title"}{Zoem User's Manual}
\set{"tut::day"}{19}
\set{"tut::month"}{February}
\set{"tut::year"}{2002}
\set{"tut::author"}{Stijn van Dongen}

\preamble

\def{builtins}{\v{\\\\}, \v{\\\{}, \v{\\\}}, \v{\\,},
\v{\\~}, \v{\\|}, and \v{\\-}}

\def{v#1}{\vbt{\1}}
\def{pr#1}{\@{<a href="#\1">}\v{\\\1}\@{</a>}}
\def{pref#2}{\@{<a href="#\1">}\2\@{</a>}}
\def{cref#1}{\lref{\1}{\refcaption{\1}}}
\def{enref#1}{\@{<a name="\1"></a>}}
\def{refto#2}{\@{<a href="#\1">}\2\@{</a>}}
\def{zarg#1}{\v{<\1>}}

\sec1{nutshell}{Zoem in a nutshell}

   \bf{Zoem:} <Dutch> The sound made by electrical devices and flying bugs.

\enref{bestbug}
\par
 Zoem is for creating reusable frameworks in which a single document is
 forked into different formats or mark-ups. Differently put, it allows the
 creation and usage of dummy mark-up macro languages and mapping those dummy
 languages to real mark-up languages.  Hey, ok, it's the umpteenth authoring
 tool, but that's not all there is to it.  It's a language, a parser, and a
 way of doing things.

\par
 Zoem proved its worth (or so I think) by the manual macros that facilitate
 easy creation of \lref{manexample}{good looking manual} pages in both html,
 for rendering in browsers, and troff, for rendering in terminals and
 PostScript.  Another way I use it is for producing HTML such as what you are
 looking at now. Zoem allows the creation of mark-up that has semantic and/or
 functional meaning and does multiple things at the same time.  This makes it
 easy to keep your documents consistent, easy to write, and easy to change.
 The many cross-referenced sections, term lists, and definition lists in this
 manual were all created from simple macros that reflect their purpose and can
 be changed as desired. A section is started as

\begin{vbt}
   \\sec{nutshell}{Zoem in a nutshell}
\end{vbt}

 This increments the section counter, creates the header and an anchor
 (accessible by the label \v{nutshell}),
 and creates a table of contents entry (linked to the section).
 If desired, the macro (which itself is certainly not a zoem primitive)
 can be adapted to accomodate other needs.
 By entering

\begin{vbt}
   \\lref{nutshell}{like so} is a link to Section \\refnumber{nutshell},
   \\lref{nutshell}{\\refcaption{nutshell}}.
\end{vbt}

 one obtains
 \lref{nutshell}{like so} is a link to Section \refnumber{nutshell},
 \lref{nutshell}{\refcaption{nutshell}}.

\par
 This manual covers the whole zoem language. A large part of it is only
 interesting for someone writing a reusable macro package. A smaller part is
 still interesting for someone who is just using such a package, but might
 want to add some utilities and shortcuts of his own. The part where file
 inclusion, macro definitions, and macro expansions are explained is required
 reading for anyone considering or planning to use zoem.  The manual also
 covers an example manual page written using the zoem manual macros, and the
 results after conversion to html and (PostScript generated from) troff
 (\lref{manexample}{Section \refnumber{manexample}}, see the table of
 contents below).

\sec2{}{About this document}
 Clicking on the number to the left of a section title (e.g.
 the 1.1 to the left of the title \bf{About this document} of this section)
 will get you to the table of contents.

\par
 Zoem input and zoem output are \it{both} generally shown in a typeface
 font, \v{like this}.

\maketoc

\sec2{purpose}{Purpose, method, man pages}
 Zoem was first used for generating manual pages in both HTML
 and troff from the same source. In HTML, cross-references show up as links,
 and a table of contents is automatically added [of course, the page
 you are reading was created with zoem as well].

This functionality is not directly supported by Zoem; it is obtained by
 assembling Zoem primitives into higher-level units. These particular units
 are one possible set of Zoem man macros.  Normally, not a single zoem
 primitive is encountered in a zoem manual page - it should consist of
 high-level macros only.
 The largest part of this manual is concerned with the zoem primitives and
 how to assemble them into macro packages that facilitate mapping input to
 different devices. But:

\par
 A \lref{hello}{simple hello world example} shows the basic idea behind zoem.
 For an example manual page view (in this document) \lref{manzoem}{the zoem
 source}, \lref{manhtml}{the rendered html resulting from that source}, and
 (external document) \href{buzz.ps}{the rendered PostScript compiled from the
 troff source compiled from the zoem source}.  \lref{manlisting}{An annotated
 list of the manual macros} is given in the same section.  The section
 thereafter, \cref{anatomy}, explains the anatomy of some of the man macros
 used.

\par
 Zoem supports several programming constructs, immediate and postponed
 expansions, stream character filtering, easy I/O facilities, integer
 arithmetic, and a whole lot more.
 Its four main aims are:

\begin{cblist}
\@{<li>}
   Providing the building blocks for a structural and programmable approach.
   
\@{<li>}
   Accepting a pleasant syntax that does not require too much thinking (by
   simplicity and rigor rather than by looseness).

\@{<li>}
   Creation from the keyboard while minimizing on key-strokes.

\@{<li>}
   Adding filtering capabilities so that multiple devices can be
   addressed.
\end{cblist}

\par
 Zoem's biggest advantage: you can accomplish almost anything you
 want. One price you pay is that the source document must obey zoem syntax.
 One price that you \it{don't} pay is that zoem is not a mark-up language in
 itself. Zoem knows nothing whatsoever about paragraphs, lay-out, font
 weights, slant, sections, and headers.
 There are two sides to this.

\par
 On the one hand, \it{every} aspect of authoring has to be encoded somewhere,
 e.g. lists, verbatim environments, et cetera. Making this work for multiple
 devices can be quite challenging.

 You have to teach zoem, or perhaps somebody else has already taught it
 before, or perhaps someone has already done something similar that only
 needs a little adjusting.  Zoem distinctly enables and promotes reuse and
 the creation of macro packages.  All the same, making a zoem paragraph macro
 or a zoem boldface macro and mapping those to both html and troff is quite
 easy; making a general purpose zoem list macro and mapping \it{that}
 is a lot more difficult.

\par
 On the other hand, this difficulty is exactly what makes most authoring
 solutions for multiple devices fail somewhere.  By keeping authoring issues
 out of the core zoem language, and focussing on small and powerful building
 blocks, zoem makes the playing field very large. If two devices
 support the same kind of authoring construct, then you really should
 be able to unify them in zoem.

\par
 One can (and should) isolate device specific instructions from
 authoring specific instructions, and those should again be encapsulated
 in macro packages.

 Reuse is essential: I use the same set of zoem man macros for
 all the manual pages that I write. The macro definitions themself
 are not too pretty (nor horrid) to look at, but the zoem source
 for the manual pages themself (importing the macros) looks a lot
 like TeX and may even be somewhat easier on the eye.

\par
 In general, low-end macros have to be defined and mapped onto each output
 device.  Device-specific macros must be written by someone whose knowledge
 about output devices matches the desired level of typesetting
 sophistication.  This is a pain on the one hand, on the other hand, this
 will ensure that you succeed in what you are aiming at. Moreover, high-end
 macros generally do not need device-specific instructions, so these need
 only be defined once.

\par
 If the output device has no macro facilities (HTML) or has interesting
 syntax and whitespace restrictions (troff), zoem may be a gain even if you
 need only one device.  It is very easy to (conditionally) include
 device-specific material in the running zoem text itself.

\sec2{}{Itches}
\par
 Zoem was created because several of the author's itches were scratched
 by other approaches.

 I disliked existing ways of generating manual pages in both troff and html.
 These are always about converting from one mark-up language to one or more
 others, and they are invariably broken. More often than not it is a hugely
 unwieldy Perl script. Zoem was designed with the explicit goal of device
 forking, and zoem is not a mark-up language. It's a way of \it{creating}
 dummy mark-up languages with a TeX-like syntax. The notion of mapping the
 dummy language to a real mark-up language is built into the very DNA of
 zoem.  Since manual pages do not need a large set of mark-up features, this
 is a very feasible approach.

\par
 I was inspired by the leaden-footed approach of the SGML/XML/DocBook setup,
 which makes me nearly crave for a GUI because the typing is so cumbersome,
 with tags all over the place and no good macro facilities.
 That does something to a vim/tex/mutt/nn user, wondering whether he
 should use a GUI for flushing his writings. It's more like pulling a leg
 than scratching an itch.
 \bf{I need to type my documents and I need to have powerful macro
 facilities} \- as I need semantic mark-up that will do
 multiple things at the same time.

 So I disagree somewhat with what demigod James Clark (of groff, expat,
 SP, and XML fame) has to say about this:

\begin{quote}
   One lesson I drew from TeX and groff is that you want a real programming
   language, not a macro processing language. When you look at the thousands of
   lines of TeX macros or troff macros that people produce, it's a monument to
   the human intellect, but it's not really the right way to solve the problem.
\end{quote}

\par
 For my everyday document, I don't think I need something that has all the
 generality, power, and inconvenience of attribute grammars and feature
 structures mixed with relational databases, i.e. the kind of thing that
 people usually write a thesis about, not with.  This is probably grosly
 misunderstanding, misrepresenting, and altogether missing the point, but
 from the point of zoem's existence, the point is pointless anyway.  Of
 course, using zoem to output XML is a very viable option - for my everyday
 document again, I do understand that publishers and the likes have different
 needs.

\par
 I was inspired in a positive way by the TeX syntax and design.  TeX really
 enables the rapid creation of documents over which the creator is able to
 maintain powerful control by creating his own \it{semantic} mark-up -
 I am not even mentioning TeX's superb typesetting capabilities here.
 Zoem syntax
 was copied in a \lref{nomenclature}{modified form} from TeX (please note
 that zoem is absolutely infinitesimal in aim and scope). Then there is
 troff. I would love to love it, but the more I get to know it, the more I
 marvel at its insane syntax. It is beyond me that anyone would enter (of
 their free will) a document in plain troff. Still, troff has a special place
 in my heart, and I am quite happy to produce (reasonably simple) troff by
 mapping zoem macros to troff input.

\par
 Finally, info was a big itch on its own. If ever I saw an attitude problem
 matched only by the absence of achievement (that's a gripe about info, not
 texinfo, mind you). Admittedly, RMS is a giant and me just a dwarf squashed
 beneath his feet, which may explain why I cannot look any further.  Count me
 in with all the other dwarfs squeaking they don't like info one bit.

\: A notable feature is the distinction between device space and plain space
\: or content space.

\sec2{}{Examples}
\par
 The zoem man macros for the two devices HTML and roff were written by Stijn
 van Dongen and use a straightforward subset of HTML and the troff man
 macros plus a little additional plain troff (thanks go to Jan van der Steen
 for that).  Zoem input written in these macros yields cross-referenced html
 including a table of contents if desired, while at the same time a
 classic-style manual page can be produced.  The good thing of zoem is that
 you can easily modify, improve, and replace these macros to suit your own
 needs.  The page you are currently reading was created using macros which
 were morphed from the man macros.  See the \cref{hello} and
 \cref{manexample} sections.

\sec2{}{Expressive power (features)}

\par
 Below you find some features of the zoem primitives. Note that there are in
 practice two kinds of zoem files. The first is a zoem macro file, which
 should contain macros defined in terms of lower-level macros, with
 zoem primitives at the lowest level. The
 second is a zoem document file, which should import such a macro file and
 only use the high-level macros defined in that macro file. Additionally, a
 document file can define some high-level macros of its own, in terms
 of low-level macros, zoem primitives, or a mixture of both.

\begin{cblist}
\@{<li>}
   Macros with arguments, overloading of key names allowed (i.e. different
   keys with the same name are distinguished by the number of arguments they
   take).
\@{<li>}
   Easy file, stdin, stdout, and stderr input/output,
   nested file inclusion.
\@{<li>}
   A separate namespace for integer counters, support for
   integer multiplication, addition, subtraction, division,
   and modulus.
\@{<li>}
   A separate namespace for references. References can have
   up to five members: caption, number, level, type, and misc.
\@{<li>}
   Conditional operators on integers (\pr{icmp#5}), strings
   (\pr{ifeq#4}) and keys (\pr{ifdef#3}, \pr{ifdefl#3}).
\@{<li>}
   The while expression \pr{while#2}, and the \it{for}-like
   primitives \pr{apply#2} and \pr{table#5}.
\@{<li>}
   Support for variable number of arguments
   - see the \lref{vararg}{vararg} section.
\@{<li>}
   The switch primitive \pr{switch#2},
   employing the \lref{vararg}{vararg construct}.
   Yes, zoem has a switch statement, and it takes arbitrary expressions too!
\@{<li>}
   Localized expansions (\pr{setx#2} and \pr{dsetx#2})
   and meta-zoem (\pr{meta#3}).
\@{<li>}
   A user dictionary stack that can be manipulated using \pr{push} and
   \pr{pop}.  An environment environment for doing \v{\\begin{stuff}} \v{..}
   \v{\\end{stuff}} stuff (see \pr{env#3}).  This enviroment respects scopes by
   pushing and popping to/from the \lref{dictionary}{dollar dictionary stack},
   and it allows the specification of overloaded environments. For example,
   this could make both \v{\\begin{itemize{bullet}{compact}}} and
   \v{\\begin{itemize{custom}}} possible.  It must still be seen whether this
   is actually useful though.

\@{<li>}
   Storage of data by multiple string indexing \- data is stored
   in a tree by indexing nodes with (arbitrary) strings.
   Responsibility of the \pref{dset#2}{group of d-keys}.

\@{<li>}
   The ability to nicely format macros (see \pr{formatted#1}).
\@{<li>}
   And more.
\end{cblist}

\sec2{}{Limitations and difficulties}
\par
 If you want to do arbitrarily complex stuff, it will be difficult
 to map it onto multiple devices. That is true for any system however,
 and zoem can still be very useful for example when you like the TeX
 way of creating documents whereas you need HTML output.

\par
 Tables are notoriously difficult to maintain along multiple devices.  With
 zoem one should be able to aim for a least common denominator.  I have not
 yet attempted to create such a forked table enviroment (which would likely
 benefit from the \pr{table#5} and \pr{apply#2} primitives), mostly because
 tables are neither common nor easily implemented in manual pages that are
 meant to be read in terminals.  The usual approach towards tables in manual
 pages is to use a verbatim environment like so:

\begin{vbt}
   .-------.-------.-------.
   |       |       |       |
   |   8   |   1   |   6   |
   |       |       |       |
   .-------.-------.-------.
   |       |       |       |
   |   3   |   5   |   7   |
   |       |       |       |
   .-------.-------.-------.
   |       |       |       |
   |   4   |   9   |   2   |
   |       |       |       |
   .-------.-------.-------.
\end{vbt}

 The zoem manual pages provides a \v{vbt} environment and a
 \v{vbtbl} environment for this. The latter, a 'verbatim table',
 will not be split over two pages by troff (if it fits on a
 single page).

\par
 The zoem manual pages posed interesting difficulties when I looked further
 than html under Netscape and troff under groff.  Making things work for both
 Netscape and Internet Explorer (with respect to spacing in lists) and for
 both GNU troff (groff) and other (older and proprietary) troff versions
 (with respect to the \v{verbatim} environment) was interesting, to say the
 least.  Some issues sprang from my own mistakes, and I learned a couple of
 things along the road. Notably the existence of \v{\\e} and \v{\\&} in
 troff, and the power of the \v{<div>} and \v{<span>} elements in HTML.
 The list issue seems unsolvable using orthodox methods, as the list
 environments are broken in different ways and degrees in the various
 browsers (e.g. mangling the margin attributes).  The table of contents
 section is still not satisfactory under certain (all?) IE versions.

\par
 One unfortunate matter is the following. I have become quite attached to
 using \it{italics} in manual pages, as groff does a good job (in terminals)
 of rendering italic text as underlined - when groff produces PostScript it
 will simply render italics of course.  Other and older versions of troff
 seem to render italics by switching to reverse video, which gives a
 horrendous effect.  Beware of this, and avoid italics if you want to
 optimize the worst case user experience.  Another thing is that older troffs
 don't seem to justify paragraphs as groff does.


\sec2{}{Premises and generalizing zoem}
\par
 The usefulness of zoem depends on the  premise that mark-up languages like
 troff, html, and TeX possess certain orthogonality properties.  One such
 property is that escaping a special character in order to obtain the glyph
 it normally represents can be done unambiguously and does not depend on some
 context like e.g. \it{mathematics}, \it{header}, \it{verbatim}, or
 \it{itemize}.  Another is that environments like lists and paragraphs can be
 nested freely.  Luckily this is what everyone expects from a sane mark-up
 language, and most mark-up languages try to be sane. If a mark-up
 language fails to meet this requirement, you will have to
 work within the restricted area of the language that \it{does}
 meet the requirement.

\par
 Zoem's behaviour right now is extremely straightforward.
 \lref{dichotomy}{It distinguishes
 two scopes}, plain scope and device scope. When plain scope is
 output, any character that is special to the output device is translated
 to the corresponding 'magic sequence' for that device. When device
 scope is output, nothing is mapped, and some additional primitives
 for regulating the output of white space are available.

\par
 For example, the zoem manual macros map every period '\v{.}'
 encountered by zoem in plain scope onto the sequence '\v{\\&.}' [sic],
 if the output device is troff. They map every ampsersand '\v{&}'
 onto the sequence '\v{&amp;}' if the output device is html.
 However, the first example is slightly overdoing it. In troff, a dot
 only has magic powers if it is the first character on a line.
 Zoem currently provides no way of recognizing this kind of subtlety.
 The natural generalization of the present scope model would
 be to equip zoem's output behaviour with a finite state automaton.
 I hope that this will never be necesary though, as the simplicity
 of the present model is gratifying and promotes robustness when
 constructing high-level macros.

\sec2{}{Inhabitants of the authoring ecosphere}

\par
 If zoem is not what you are looking for, you might be interested in one of
 the following. The links are to Google searches, as I am lazy and the items
 are in varying states of being supported.

\@{<div style="margin-top:1em">
<table summary="col1=utility col2=google search">
}
\apply{_#2{
   \@{\%N%<tr>\%N%<td width=20% align=left>\%NT%}\1
   \@{\%NB%</td>\%N%<td width=80% align=left>\%NT%}\2
   \@{\%NB%</td></tr>}
}}{
 {\href{http://www.google.com/search?q=aft+almost+free+text}{\bf{aft}}}
 {almost free text}

 {\href{http://www.google.com/search?q=gellmu}{\bf{gellmu}}}
 {generalized extensible LaTeX-like markup}

 {\href{http://www.google.com/search?q=htlatex}{\bf{htlatex}}}
 {hypertext LaTeX}

 {\href{http://www.google.com/search?q=gnu+info}{\bf{info}}}
 {GNU info, from the folks that abhor man pages and love topic splatter}

 {\href{http://www.google.com/search?q=latex2html}{\bf{latex2html}}}
 {latex to html, on my system a 17032 line Perl-script}

 {\href{http://www.google.com/search?q=latex2man}{\bf{latex2man}}}
 {latex to man}

 {\href{http://www.google.com/search?q=man2html}{\bf{man2html}}}
 {man to html}

 {\href{http://www.google.com/search?q=mtex+tex+macros}{\bf{mtex}}}
 {manual TeX [by Mike Sofka]}

 {\href{http://www.google.com/search?q=mtex+lim}{\bf{mtex}}}
 {manual TeX [by Compaq]}

 {\href{http://www.google.com/search?q=pod+plain+old+documentation}{\bf{pod}}}
 {plain old documentation (Perl's documentation format)}

 {\href{http://www.google.com/search?q=tei+text+encoding+initiative}{\bf{tei}}}
 {text encoding initiative}

 {\href{http://www.google.com/search?q=tex4ht}{\bf{tex4ht}}}
 {TeX for hypertext?}

 {\href{http://www.google.com/search?q=wlatex}{\bf{wlatex}}}
 {web LaTeX?}
}
\@{\%N%</table></div>\%N%}

\par
 There seem to be \it{two} thingies named mtex, one by Mike Sofka, one by
 compaq (as a collection of LIM scripts).
 I believe that the latter mtex shares some of the ideas behind zoem.

\sec1{hello}{zzello world}

\par
 A not entirely trivial hello world example, featuring the concepts of
 \it{plain} scope and \it{device} scope. The latter should only be seen in
 macro packages. The distinction between these scopes is essential to zoem,
 and is thoroughly explained in the \cref{dichotomy}
 and \cref{dscope} sections.  The sequence \v{\\@{..}}
 encloses device scope, the sequence \v{\\:} introduces a comment until the
 end of line. \pr{switch#2}, \pr{def#2}, and \pr{special#1} are
 zoem primitives, \v{\\define} is a predefined key. The mappings defined
 by \pr{special#1} live in device scope.

\sec2{}{The macro file}

\par
Say this macro file is named \v{simple.zmm}.

\prule
\begin{vbt}
\\: -----------------------------------------------------------------
\\: Stuff such as this belongs in a (reusable) macro file.
\\: \\bf#1 and \\par need device specific sequences.
\\: \\special#1 maps characters with meta meaning in plain scope.
\\: \\@{..} encloses device scope: nothing is mapped therein.
\\: -----------------------------------------------------------------
\\switch{\\$device}{
   {html}{
      \\def{bf#1}{\\@{<b>}\\1\\@{</b>}}
      \\def{par}{\\@{<p>\\%N%}}
      \\special{             \\: how to map characters in plain scope.
         {38}  {&amp;}      \\: 38 is ascii character '&'
         {60}  {&lt;}       \\: 60 -> '<'
         {62}  {&gt;}       \\: 62 -> '>'
      }
   }
   {roff}{
      \\def{bf#1}{\\@{\\\\fB}\\1\\@{\\\\fP}}
      \\def{par}{\\@{\\%P%}}
      \\special{             \\: how to map characters in plain scope.
         {46}  {\\\\.}        \\: safest to escape each dot ..
         {96}  {\\\\`}        \\: a left quote must be escaped ..
         {92}  {\\\\\\\\}       \\: a backslash must certainly be escaped ..
      }
   }
}
\end{vbt}

\sec2{}{The document file}

\hrule

\begin{vbt}
\\ifdef{$device}{}{\\set{$device}{html}}
   \\: (set the device if not defined from command line).
\\import{simple.zmm}
\\def{greet}{\\bf{greetings}} 
\\def{greet#1}{\\bf{hello \\1!}} 
\\def{greet#2}{\\bf{\\1 \\2!}} 

\\: Use the keys just defined. Some kind of overloading there.
\\: the '&' will be automatically mapped and so will '<' and '>'.

\\par
The other day I said \\greet{Venus & Serena}, and they said cheerfully
\\greet{<morning>}{Truman}, give Laura our best \\greet please.
\end{vbt}

\sec2{}{The output}

\par
This is the output:

\begin{vbt}
<p>
The other day I said <b>hello Venus &amp; Serena!</b>, and they said cheerfully
<b>&lt;morning&gt; Truman!</b>, give Laura our best <b>greetings</b> please.
\end{vbt}

which renders of course as
\@{<p>
The other day I said <b>hello Venus &amp; Serena!</b>, and they said cheerfully
<b>&lt;morning&gt; Truman!</b>, give Laura our best <b>greetings</b> please.}

\par
You can look at a much more sophisticated example in the
\bf{\refcaption{manexample}} section. Go to the
\lref{manexample}{top of that section} for an annotated list of the zoem
manual macros, witness an \lref{manzoem}{example page in zoem format},
scrutinize the \lref{manhtml}{rendered resulting html}, or
gaze at the \href{buzz.ps}{postscript compiled by groff from the
troff output created from the zoem  input}.

\sec1{cline}{Invoking zoem from the command line}

\par
 You use zoem by invoking it from the command line. The normal mode of
 operation is that you specify a file for zoem to chew up and spit out.  This
 is called the \it{entry file}, and its name \it{must} have a \v{.azm}
 extension.  The other thing you normally specify is the device, which will
 just assign a value to the predefined \v{\\$device} key.  A common invocation
 thus looks as follows:

\begin{vbt}
   zoem -i mcl.azm -d html
\end{vbt}

 The \v{-i} flag specifies the entry file and the \v{-d} flag
 sets the \v{\\$device} key. It is not necessary to write the \v{.azm}
 extension, zoem will append it for you. The preceding could also
 have been entered as

\begin{vbt}
   zoem -i mcl -d html
\end{vbt}

 In either case, zoem will set the predefined key \v{\\$base}
 to the base name of the entry file, i.e. the name stripped of its
 \v{.azm} suffix. In this example, the key \v{\\$base} will get the
 value \v{mcl}.

\par
 Zoem writes its output to a file which is named according to three
 rules. Note that zoem can also write to other files, use
 the \pr{write#3} primitive for that. The rules are:

\begin{cblist}
\@{<li>}
   If the \v{-o} flag was given with value say \v{somestr},
   zoem will write to the file named \v{somestr}.
\@{<li>}
   If \v{-o} was not supplied but the \v{-d} flag was used with argument say
   \v{zyx}, zoem will write to the file named \v{\\$base.zyx}.
\@{<li>}
   If neither \v{-d} nor \v{-o} was given, zoem will write to the
   file named \v{\\$base.ozm}.
\end{cblist}

\par
 Both the \v{-i} and \v{-o} flag accept a hyphen as argument,
 meaning respectively that zoem will read from stdin and write
 to stdout.

\par
 Specifying just zoem and entering a return will cause zoem
 to read from stdin and write to stdout. I use it sometimes
 for testing purposes. Other flags are:

\: mq
\begin{itemize}
\itemnew
\item{\v{-h}}
\itemdef
   lists all flags accepted by zoem.
\itemend

\itemnew
\item{\v{-l <str>}}
\itemdef
   lists all entities specified by \v{<str>}. It can be any of
   \v{all}, \v{zoem}, \v{legend}, \v{macro}, \v{session}, or \v{list}.
   Repeated use is allowed. In fact, zoem will only check whether
   the target is present as a substring, so

\begin{vbt}
   zoem -l legendzoem
\end{vbt}

   will print the legend and the list of zoem primitives. 
\itemend

\itemnew
\item{\v{--trace}}
\itemdef
   This traces (prints) all keys encountered, and  prints
   possibly truncated arguments.
   Use the \v{-trace <k>} option (see below) for finer control,
   and note that tracing can be set from within the document
   using the \pr{trace#1} primitive.
\itemend

\itemnew
\item{\v{-trace <k>}}
\itemdef
   Sets a tracing mode. 1 activates long listing mode in which strings may
   spread over multiple lines (default mode truncates at a single line), 2
   activates key listing, 4 activates argument listing, 8 activates defs
   listing (definitions of keys are shown), 16 activates vararg listing (the
   vararg elements are shown), 32 activates segment listing (the pieces
   manipulated internally by zoem), and 64 activates output tracing.  Add the
   things you want to have, so use \v{-trace 22} if you want to see how keys,
   arguments, and varargs are parsed.

\par
   The value \v{-1} activates all tracing levels in short listing mode,
   \v{-2} activates all tracing levels in long listing mode.

\par
   Tracing can be set from within the document using the
   \pr{trace#1} primitive. Part or whole of the data tree
   can be output from within the document using \pr{dprint#1}.
\itemend

\itemnew
\item{\v{--stats}}
\itemdef
   When zoem is done, it prints statistics about the primitive name
   table and about the user name table.
\itemend
\end{itemize}

\sec1{syntax}{Zoem syntax and parsing}

\sec2{nomenclature}{Syntax and nomenclature}
\par
 Zoem parses text which may contain zoem \bf{escape sequences}, these are
 sequences that have special meaning and cause zoem to do special
 processsing. Each and every escape sequences starts with a backslash, no
 exceptions.  There are three kinds of sequences that are \it{macros}, which
 may or may not take arguments.  These are zoem primitives, user keys, and
 dollar keys. The latter are, among others, for use by both zoem and the user
 for shadowing and recovering information in nested scopes.

 There are currently roughly forty zoem primitives, these are listed in the
 \cref{language} section.  User keys and dollar keys are discussed in the
 \cref{macro} section. Arguments are shipped by delimiting them with curly
 braces, as in

\begin{vbt}
   \v{\\thiskey{takes}{\\bf{two}\\it{arguments}}}.
\end{vbt}

\par
 No characters are allowed inbetween (the delimiting curlies of) two
 arguments (but take note of the handy \pr{formatted#1} primitive).  See the
 \cref{macro} section for more information.

 Zoem is very strict in the syntax it accepts, but it \it{garantuees} to
 accept a text in which each backslash \v{\\} is escaped as \v{\\\\} (i.e. a
 text in which all consecutive runs of backslashes have even length).

\par
 An \bf{active backslash} is any backslash that is not made inactive by an
 active backslash immediately preceding it. The first backslash seen by zoem
 (proceeding sequentially through the text) is active.  This is one
 incomprehensible way of stating the obvious, and I bet you know what I mean
 anyway.  An active backslash must always have a meaning known to zoem.  If
 zoem does not get it, it will complain and exit.  The meaning (i.e. class)
 of the escape sequence introduced by an active backslash is determined by
 the character immediately following it. A list is given below.

\par
 Within arguments, curlies not functioning as argument delimiters must also
 be escaped if they are not balanced. It is best practice to escape all
 non-argument-delimiting curlies, but I never do so myself unless they are
 not balanced.  An \bf{escaped curly} is a curly preceded by an active
 backslash.  An \bf{active curly} is a curly that is not escaped.  A pair of
 \bf{balanced curlies} consists of an active left curly that matches an
 active right curly, where inbetween all escaped curlies are disregarded.  A
 \bf{scope} is anything delimited by balanced curlies. Sometimes, the word is
 also used to refer to the stuff enclosed by instances of the \pr{begin#1}
 and \pr{end#1} primitives.

\sec2{escape}{List of escape sequence classes}
\par
 This is a list of escape sequence classes recognized by zoem, indexed
 by the (set of) character(s) triggering the class(es) \- this assumes
 that the character in question is preceded by an active backslash.

\begin{itemize}

\itemnew
\item{\v{$[_a-zA-Z]*}}
\itemdef
   A sequence starting with a dollar sign possibly continued with
   underscores and alphanumeric characters.  Introduces a dollar key. No
   dollar signs are allowed in the remainder, and the first non-alphanumeric
   non-underscore character terminates the sequence.  Any key that is set by
   zoem itself (and which is not simply an alias) takes the form of a dollar
   key.  Examples of these are the keys set by \pr{begin#1} and \pr{end#1},
   and the zoem \lref{session}{session keys}.  Dollar keys live in the
   dollar dictionary stack, over which the user has no control (it
   is pushed and popped strictly by \pr{begin#1} and \pr{end#1}).  Refer
   also to the \cref{macro} section, the \cref{language} section, and the
   \cref{dictionary} section.

   \par
   Note: \pr{$#2} is a zoem primitive.
\itemend

\itemnew
\item{\v{[_a-zA-Z][_a-zA-Z0-9]*}}
\itemdef
   A sequence starting with an underscore or an alphabetic character, with
   only underscores and alphanumeric characters in the remainder.
   Introduces a user key or a zoem primitive.  The first non-alphanumeric
   non-underscore character terminates the sequence.  These keys live in the
   \it{user dictionary stack}, which the user can control with the \pr{push}
   and \pr{pop} primitives. Refer also to the \cref{macro}, \cref{language},
   and \cref{dictionary} sections.

   \par
   A sequence consisting of a single underscore (i.e. not followed
   by an alphanumeric character) introduces an
   \lref{anonymous}{anonymous key}.
\itemend

\itemnew
\item{\v{"}}
\itemdef
   Starts a user key, which is only different from the user keys mentioned
   above in that it looks different. The sequence is terminated by
   a closing \v{"}. Inbetween, anything is allowed except
   a backslash or curly. This is used for creating mnemonic names such as 
\begin{vbt}
   \\"man::author"
   \\"man::section"
   \\"man::version"
\end{vbt}
\par
   These keys live in the \it{user dictionary stack}.
   See the \cref{macro} section and the \cref{dictionary} section.
\itemend

\itemnew
\item{\v{[1-9]}}
\itemdef
   A single (character encoding a) positive digit. This is currently only
   interpreted in the second argument of \pr{def#2} and \pr{set#2}, or in
   the definition part of an \lref{anonymous}{anonymous key}. In all these
   instances, the sequence denotes a positional parameter into which the
   corresponding argument will be interpolated when a key with arguments is
   used. It is allowed in other places though, as it is possible
   in zoem to create key definitions dynamically (see e.g.
   the \pr{setx#2} primitive).
\itemend

\itemnew
\item{\v{:}}
\itemdef
   This comprises the comment sequence. It starts a comment that is
   terminated by a newline and stripped during file read (cf the
   \cref{fileread} section).  During file read, zoem
   only checks whether the leading backslash preceding the colon is active.
   It does not check whether the sequence is contained in some scope (e.g.
   nested in the argument to some key) - that is in fact explicitly allowed
   and useful in  commenting large macro sequences contained in the
   \pr{formatted#2} primitive.
\itemend

\itemnew
\item{\v{@}}
\itemdef
   Starts a special instance of device scope called \it{at scope}.  The
   sequence \v{\\@} \it{must} immediately be followed by a pair of balanced
   curlies, so at scope always appears as \v{\\@{..}}.  Refer to the
   \cref{dichotomy} and \cref{dscope} sections for more information.
   \it{Typically seen in macro package files only}.
\itemend

\itemnew
\item{\v{*}}
\itemdef
   Starts a glyph sequence or constant sequence (that is terminated
   by another \v{*}). Refer to the \cref{dscope} section and to the
   \pr{constant#1} primitive.
\itemend

\itemnew
\item{\v{%}}
\itemdef
   Starts a formatting sequence (that is terminated by another \v{%}). These
   are allowed in two scopes only, and serve a different though similar
   purpose; within the \pr{formatted#1} primitive they regulate what zoem
   does to the white space encountered in its input, and in
   \lref{dscope}{device scope} they regulate how zoem outputs white space.
   \it{Typically seen in macro package files only}.
\itemend

\itemnew
\item{\v{=}}
\itemdef
   Starts either a sequence of the form \v{\\=fname=}, which begins a so called
   inline file named \v{fname}, or a sequence of the form \v{\\==}, which
   ends such an inline file. Refer to the \cref{fileread} section.
\itemend

\itemnew
\item{\v{,}}
\itemdef
   The atomic separator. This is interpreted during filter time, and is
   always mapped to nothing. Use it for glueing things as in \vbt{\\foo\\,1},
   which will result in \v{theresultoffoo1}.
\itemend

\itemnew
\item{\v{|}}
\itemdef
   Comprises a special two-character sequence that can be given a
   device-specific meaning. It is customarily used to encode a line break. To
   zoem, this sequence is more or less the same as a 'normal' character. See
   the \pr{special#1} primitive.
\itemend

\itemnew
\item{\v{~}}
\itemdef
   It is customarily used to encode a non-breaking space. See the entry above.
\itemend

\itemnew
\item{\v{-}}
\itemdef
   It is customarily used to encode a long dash. See two entries back.
\itemend

\itemnew
\item{\v{\\}}
\itemdef
   Denotes a literal backslash.
\itemend

\itemnew
\item{\v{\{}}
\itemdef
   Denotes a literal left curly.
\itemend

\itemnew
\item{\v{\}}}
\itemdef
   Denotes a literal right curly.
\itemend
\end{itemize}

\par
 This leaves \v{0`'<>()[]?!^#&+/.;} for future use.

\par
 If the sequence \v{\\#} acquires meaning, it will probably be for encoding
 Unicode scalar values.

\sec2{stages}{Parsing stages}

\par
 Parsing is separated into three stages, conceptually.
 Zoem knows two different scopes, plain scope and device scope.
 These are mentioned below, and explained in the \secref{dichotomy}
 section. The three stages are:

\${html}{
\@{<ul type=bullet style="margin-top:1em">}
\@{<li>}  File read
\@{<li>}  Macro expansion / file inclusion - only plain scope is seen.
\@{<li>}  Filtering - both plain scope and device scope are filtered.
            Device directives that lay hidden in device scope
            are interpreted during output.
\@{</ul>}
}

\par
 In reality, as soon as a piece of text is no longer subject
 to the second stage, it is immediately filtered and output.

\par
 Important is that the result from the second stage is still
 valid zoem input.

 If you were to re-feed it to zoem, file read and macro expansion would both
 be no-ops, and the syntax would be acceptable to zoem.  This is because device
 scope is not touched during the first two stages, and device specific
 text (which is most likely not conforming to zoem syntax) lies always hidden
 in that scope. There are three kinds of escape sequences introducing
 device scope; these are described in the \secref{dscope} section.

\par
 This is used for example when creating a table of contents; you can write
 expanded but unfiltered content to a file and read it in during the
 following run. It is important that such content is fully expanded,
 because you want things like index numbers and references as
 they are at the time of macro invocation. It is equally important that what
 you read back in is still valid zoem  input; this is simply achieved by
 witholding filtering. When the table of contents is read in, it can be
 subjected to filtering, and this is the right way to do toc stuff in Zoem.


\sec2{fileread}{File read}
\par
   file read - stripping comments, reading inline files.

\begin{itemize}
\itemnew
\item{\v{\\:}}
\itemdef
   introduces comment until end of line.
\itemend

\itemnew
\item{\v{\\=fname=}}
\itemdef
   starts inline file named fname at the next line,
   removes remainder of line after the \v{\\=fname=} sequence.
   When using the \pr{dofile#2} primitive or one of its
   four aliases, an inline file takes precedence over regular files
   in the file system, whether it is present (as a regular file)
   or not. See below. This feature can be used to ship zoem
   input in one piece while putting the macro parts at the end.

   \par
   The future will probably bring a zoem option that creates
   such a self-contained file automatically from the zoem
   entry file.
\itemend

\itemnew
\item{\v{\\==}}
\itemdef
   ends inline file, removes remainder of line.
\itemend
\end{itemize}

\par
 The above applies to any file read at any stage.
 Inline files may occur in any file included at any time.

\par
 The \it{zoem entry file} is the single file that is specified
 on the command line. This is the main file, from which other
 files can be included if desired.

\par
 Zoem entry files \it{must} have the extension \v{.azm}, which is memnonic
 for \bf{A ZoeM} file.  It is not uncommon to generate sibling files with
 \v{.roff}, \v{.html}, \v{.zmt} (zoem table of contents), and
 \v{.zmr} (zoem references) extensions \- however, this is all configurable
 in user space and not part of zoem itself.  There are no restrictions on
 names of files that are included from the entry file. Inclusion is done
 recursively.

\par
 The future will probably bring a second extension that is allowed,
 namely \v{.ezm} for \bf{Expanded ZoeM} file, which is a self-contained
 file in which every included file is present as an inline file.


\sec2{macro}{Macro expansion}
\par
 Macro expansion consists of recursive file inclusion and macro expansion.

 All zoem primitives and user keys are recursively expanded
 until none remains. Zoem primitives and user keys take one
 of the following forms:

\begin{itemize}
\itemnew
\item{\v{\\abc_0123_}}
\itemdef
   A key with alphanumerics and underscores only. Ends with
   any other character. All zoem primitives but one have this form.
   
   \par
   Note: \v{\\_} denotes an anonymous key, see the \cref{anonymous} section.

   \par
   These keys live in the \it{user} dictionary stack. Initially, there is
   only one dictionary. The stack can be manipulated using the \pr{push}
   and \pr{pop} primitives.
\itemend

\itemnew
\item{\v{\\"abc::def-ghi.jkl,mno+qrs"}}
\itemdef
   A quoted key. Almost anything inbetween quotes is allowed. Always
   ends with a quote. No zoem primitive has this form.
   These keys live in the same \it{user} dictionary stack
   as the keys above.
\itemend

\itemnew
\item{\v{\\$abc_0123_}}
\itemdef
   A key introduced with a dollar sign, alphanumerics and underscores in
   the remainder only. Ends with any non-alphanumeric character.  These
   keys live in the \it{dollar} dictionary stack. It cannot manipulated
   by the user, but a dictionary is pushed with every occurrence of
   \pr{begin#1}, and that dictionary is popped with the corresponding
   occurrence of \pr{end#1}.

   \par
   \v{\\$0}, \v{\\$1}, .. \v{\\$9} and \v{\\$0_}, \v{\\$1_}, .. \v{\\$9_}
   are two sets of keys of which a subset is set with every occurrence of
   either \pr{begin#1} or \pr{end#1}.

   \par
   Further note: \pr{$#2} is a zoem primitive.
\itemend
\end{itemize}

\par
 All three types of keys may take arguments, and overloading is allowed:

\begin{vbt}
   \\foo                          \\: signature foo
   \\foo{bar}                     \\: signature foo#1
   \\foo{bar}{bop}                \\: signature foo#2
   \\$foo{bar}{baz}               \\: signature $foo#2
   \\"foo::oof"{zut}{zit}{zot}    \\: signature "foo::oof"#3
\end{vbt}

\par
 is an ensemble of valid and unique keys, which can be defined for
 example by

\begin{vbt}
   \\def{foo}{FOO}
   \\def{foo#1}{The FOO of \\1}
   \\def{foo#2}{The FOO of \\1 and \\2}
   \\def{$foo#2}{The $FOO of \\1 and \\2}
   \\def{"foo::oof"#3}{\\foo{\\1}{\\2}\\foo{\\2}{\\3}}
\end{vbt}

\par
 Additionally, zoem allows the definition of \it{constant keys} that map
 directly into device space and are ignored during macro expansion. Usage of
 such keys looks like \v{\\*'e*} or \v{\\*(c)*} and is detailed later on.

\par
 A sequence \v{\\k} where k is in 1-9 is only allowed in the last
 argument of the \\def primitive, and it indicates the position(s)
 where an argument should be interpolated.

\par
 A feature that should only rarely be needed is that zoem allows
 scopes to be nested. Refer to the \cref{dictionary} section.

\sec2{}{File inclusion}

\par
 There is one zoem primitive which has four different uses. For each
 of those uses, an alias exists.

\begin{vbt}
\\dofile#2 use      alias          meaning

\\dofile{expr}{!+}  \\input{expr}   require file, interpret and output
\\dofile{expr}{!-}  \\import{expr}  require file, interpret only
\\dofile{expr}{?+}  \\read{expr}    permit absence, interpret and output
\\dofile{expr}{?-}  \\load{expr}    permit absence, interpret only
\end{vbt}

\par
 The \pr{dofile#2} primitive and its four aliases are perhaps a little
 funny interface-wise \- better ideas are welcome.  The \v{expr} argument
 is \it{digested}, that is, expanded until no macro's remain. It is thus
 possible to specify \v{\\$base.zmt} and include a table of contents file
 that has been written to in a previous run.

\par
 Additionally, a file can be stored in a key:

\begin{vbt}
\\store{key}{expr}   \\: expr is expanded and used as file name.
\end{vbt}

\par
 Note: wherever \v{key} is written, it means that something
 of the form \v{\\foo}, \v{\\$foo}, or \v{\\"foo"} has to
 be provided, so you would use \pr{store#2} as
 \v{\\store{foo}{\\$base.zyx}}.

\sec2{dichotomy}{Scope dichotomy}
\par
 Zoem knows two scopes: \bf{plain scope} and \bf{device scope}.  The latter
 is also called 'at scope' because \v{\\@{..}} is one (but not the only) of
 the ways of entering device scope. In plain scope, every character
 represents itself as a glyph, i.e. as something that should show that way in
 print/on screen (after the zoem output/device input is fed to the device
 interpreter).

\par
 For example, if you write the less than sign \v{<} in plain scope,
 it should show up as a readable less than glyph, like in
 this very sentence. In order to make this happen, zoem provides
 the \pr{special#1} primitive, so that the less than sign can be
 automatically mapped to the html entity sequence \v{&lt;}.

\par
 In device scope, nothing is mapped except for a double backslash should it
 occur.  If you enter this particular sequence of mixed scope:
 \v{\\@{<b>}<hello world>\\@{</b>}} as zoem input,
 the zoem output/device input is (provided the \pr{special#1}
 primitive was correctly used for the html device):
 \v{<b>&lt;hello world&gt;</b>}
 and what you finally see on screen is:
 \@{<b>}<hello world>\@{</b>}.
 In device scope, every character (except for the escape sequences available
 in that scope) represents itself as the ASCII character that should be
 present in the zoem output/device input.  Device scope should normally only
 be seen in macros and not in running zoem input.

\par
 In plain space you type characters just as you want to see them eventually
 \- when you read the document after the zoem output was run through a device
 interpreter (such as a browser or printer, or postscript previewer).
 The only exceptions are the backslash and the two curlies, these should
 be entered as \v{\\\}}, \v{\\\{}, and \v{\\\}}, respectively.
 Those escape sequences are interpreted as the characters or glyphs
 \v{\\}, \v{\{}, and \v{\}}.  For all characters, including these
 three, it is checked whether they should be further mapped according to the
 \pr{special#1} primitive. If a mapping is found, it is retrieved
 and interpreted by the device scope filter. Read on.

\sec2{dscope}{Device scope}

\par
 There are three kind of strings which are interpreted by the
 generic device filter, and which are said to live in device scope:

\begin{cblist}
\@{<li>}
   The strings embedded in \v{\\@{..}} sequences.\|
\@{<li>}
   The strings mapped to by the \pr{special#1} primitive, including
   mappings of the zoem glyphs \v{\\~}, \v{\\|},
   and \v{\\-}.
\@{<li>}
   The strings mapped to by the \pr{constant#1} primitive.
\end{cblist}

\par
 In a macro package that is meant to work for multiple devices,
 every use of any of these constructs will typically be embedded
 in something that tests the value of the active device.
 This can be done using either \pr{ifeq#4}, \pr{switch#1},
 or \pr{$#2}, in conjuction with the pre-defined zoem key
 \v{\\$device}, containing the name of the active device (which
 can be specified on the command-line).
 The following are equivalent:

\begin{vbt}
   \\ifeq{\\$device}{html}{ \\@{<!-- (c) foo bar -->} }{}

   \\: is equivalent with

   \\${html}{ \\@{<!-- (c) foo bar -->} }
\end{vbt}

\par
 The \pr{$#2} primitive is used if something needs to be done for one
 device only, and it may occasionally appear in documents.  For example, the
 zoem man macros enable the creation of a table of contents (for both html
 and troff).  My own convention is to have a table of contents only in html,
 and I specify this using the sequence

\begin{vbt}
   \v{\\${html}{\\maketoc}}
\end{vbt}

\par
 When zoem enters device scope, it
 outputs all characters literally, except that the backslash still has
 special meaning. It is used for encoding the backlash itself (as
 \v{\\\\}), and for encoding the two curlies \v{\{} and \v{\}} (as
 \v{\\\{} and \v{\\\}}).  This is the same as in plain scope (except that
 in plain scope the resulting character may again be mapped onto something
 else, for example, in troff the backslash also needs encoding as
 \v{\\\\}).  Additionally, the backslash can be used in device scope to
 introduce a sequence enclosed by percentage signs, i.e. \v{\\%..%}.
 Inbetween a string of characters may occur, each of which must be from the
 listing below.  They are called \it{device directives}.  By default, zoem
 will never print consecutive newlines, and it will never print consecutive
 spaces or spaces at the beginning of a line.  The device directives allow
 this to be altered.

\begin{itemize}
   \citem{N}
   \itemdef  garantuee a newline
   \citem{P}
   \itemdef  garantuee a paragraph skip (two consecutive newlines)
   \citem{S}
   \itemdef  garantuee a space (except if next char is newline)
   \citem{T}
   \itemdef  increase indent by one (indent is printed after each newline)
   \citem{B}
   \itemdef  decrease indent by one
   \citem{C}
   \itemdef  set indent to zero
   \citem{n}
   \itemdef  print newline
   \citem{s}
   \itemdef  print space
   \citem{t}
   \itemdef  print tab
   \citem{w}
   \itemdef  stop managing white space (squashing spaces and newlines)
   \citem{W}
   \itemdef  start managing white space (use after \v{w})
\end{itemize}

\par
 Note that the directives mainly affect the lay-out of the device text (which
 is zoem output), not the look of the interpreted device text.  The '\v{N}'
 directive is rather important when constructing troff macros, as many
 special troff commands are encoded by a dot as the first character on a
 line, i.e. a newline followed by a dot. Since troff attaches special meaning
 to two consecutive newlines as well (interpreting it as a paragraph break),
 zoem needs to be able to specify \it{print a newline only if the previous
 character was not a newline}. This is exactly what the \v{N} directive
 means.  The '\v{W}' and '\v{w}' directives are required for enabling
 the construction of a verbatim environment.


\par
 The first kind of zoem escape introducing device scope is \v{\\@{..}}.
 The second kind comprises the \pr{special#1} mappings, including the
 three zoem glyphs \v{\\~}, \v{\\|}, and \v{\\-}. Conventionally, these
 are used to encode a non-breaking space (\v{&nbsp;} in html), a line break
 (\v{<br>} in html), and a long dash (emdash, not present in html).
 You would for example put

\begin{vbt}
\\ifeq{\\$device}{html}{
   \\special{
      {38}  {&amp;}           \\: 38 is ascii character '&'
      {60}  {&lt;}            \\: 60 -> '<'
      {62}  {&gt;}            \\: 62 -> '>'
      {256} {&nbsp;}          \\: the zoem escape \\~
      {257} {<br>\\%N%}        \\: the zoem escape \\|
      {258} {-}               \\: the zoem escape \\-
   }
}{  
}
\end{vbt}

\par
 All \pr{special#1} definitions are interpreted in device scope. For every
 character encountered in plain scope, it is checked whether a
 \pr{special#1} definition exists, if so, the corresponding string is
 retrieved and this is filtered through the device scope filter.
 Note that the three zoem glyphs described here
 may not be used in device scope, they can only be used in plain scope.  In
 device scope you will have to write the explicit, device-specific sequence
 such as \v{<br>} (in html).

\par
 The third kind of device scope strings are those mapped to by the
 \pr{constant#1} primitive. An example of (toy) usage is this:

\begin{vbt}
\\constant{
   {'e}  {&eacute;}           \\: Use e.g. as \\*'e*l\\*`e*ve (\*'e*l\*`e*ve)
   {(c)} {&copy;}             \\: Use e.g. as \\*(c)* DEEDEE (\*(c)* DEEDEE)
   {+-}  {&plusmn;}           \\: Use e.g. as \\*+-* a few (\*+-* a few)
}
\end{vbt}

\par
 This is largely convenient syntactic sugar. These constants
 could also have been defined as

\begin{vbt}
   \\def{"'e"}{\\@{&eacute;}}
   \\def{"(c)"}{\\@{&copy;}}
   \\def{"+-"}{\\@{&plusmn;}}
\end{vbt}

\par
 The idea is that the \v{\\*..*} namespace is used for glyph-like
 device-specific bindings, whereas the \v{\\".."} namespace is used for
 semantic purposes that are device-independent, but nothing prohibits you
 from fiddling with this.

\par
 Note that user keys are not allowed in device scope. The following
 is illegal:

\begin{vbt}
   \\def{az}{abcdefghijklmnopqrstuvwxyz}
   \\@{<i>\\az</i>}
\end{vbt}

\sec1{}{Zoem miscellanea}

\sec2{signature}{Key signatures}

\par
 Several keys take another key as argument, e.g. they store a value in a
 second key or check whether the second key exists.  The full list of these
 higher-level keys is \pr{def#2}, \pr{set#2}, \pr{setx#2}, \pr{store#2},
 \pr{ifdef#3}, \pr{ifdefl#3}, \pr{undef#1}, and \pr{apply#2}. In
 all cases, the argument key is passed as the first argument, by means of the
 \bf{key signature}.

\par
 For a key \v{\\key} taking \v{k} (\v{k}>0) arguments its signature is
 \v{key#k}.  The signature of a key \v{\\key} taking no arguments is simply
 \v{key}. The rule is: Key usage always includes a single
 leading backslash (this activates the key). When a key is subject
 of inspection, it is always referred to by its signature.

\par
 Throughout this text, a key with signature \v{key#k} is mentioned
 by means of its \bf{key mention} \v{\\key#k}, that is, for extra clarity
 the backslash is prepended to the signature.

\sec2{anonymous}{Anonymous keys}

\par
 A single underscore introduces an \bf{anonymous key}.  It is optionally
 followed by a \v{#k} tag (for \v{k} in \v{0..9}), denoting the number of
 arguments the anonymous key takes. An occurrence of the latter is called a
 \bf{tagged anonymous key}.  The first argument to the key should be a key
 definition, the other arguments are the arguments for that key definition.
 If a tag is present, it is used for verifying that the anonymous key is used
 properly. This feature may be helpful when an anonymous key is the result of
 expanding the first argument to \pr{meta#3}.

\begin{vbt}
   \\_{\\1 the \\2}{row}{boat}}
   \\_#2{\\1 the \\2}{row}{boat}}
\end{vbt}

 results in

\begin{vbt}
   row the boat
   row the boat
\end{vbt}

 and

\begin{vbt}
   \\def{foo}{#2{\\1 the \\2}}
   \\def{bar}{#3{\\1 the \\2 and \\3}}

   \\meta{_\\foo}{x}{{billy}{kid}}
   \\meta{_\\bar}{x}{{william}{fourth}{maxima}}
   \\meta{_\\bar}{x}{{william}{fourth}}
\end{vbt}

 results in

\begin{vbt}
   billy the kid
   william the fourth and maxima
\end{vbt}
   
 and the third will fail.

\par
 Anonymous keys may occur in the first argument of both \pr{meta#3}
 and \pr{apply#2}, and they may occur freely in running text.
 The latter is unlikely to be useful, but \pr{meta#3} constructs
 such a free occurrence from its arguments.
 Anonymous keys are always allowed to carry a tag.
 The presence of a tag is required in the first argument of \pr{apply#2}.
 An example of usage in  \pr{apply#2}:

\begin{vbt}
\\apply{_#2{\\1 kisses \\2\\|}}{{bill}{max}{max}{bill}}
bill kisses max
max kisses bill
\end{vbt}
   
 or even

\begin{vbt}
\\dset{foo}{{{\\1 hugs \\2\\|}}}
\\apply{_#2\\dget{foo}}{{bill}{max}{max}{bill}}
bill hugs max
max hugs bill
\end{vbt}

 Note that in order to store a block with \pr{dset#2}, an extra pair of
 curlies has to be used, as blocks can only be passed as a sub-argument of a
 single-element \lref{vararg}{vararg}.  Also note that in a vararg it is
 allowed to put white space inbetween the constituting elements.

\sec2{vararg}{Of blocks and varargs}

\par
 A \bf{block} is a string beginning with a left curly and ending with a right
 curly, the curlies being balanced.  This is a convenient naming
 convention. Blocks can be used in constructing anonymous keys; refer to the
 \cref{anonymous} section.

\par
 Some keys take a \it{vararg} argument, which is a single argument (enclosed
 by curlies as are all arguments), which can contain any number of
 sub-arguments, that is, a list consisting of blocks. Inbetween the blocks
 white space may occur.  The \pr{special#1} and \pr{constant#1} keys both
 take a single vararg argument, and the \pr{apply#2} and  \pr{switch#2} keys
 each take a vararg as their second argument. For \pr{apply#2} the first
 argument is a key that is applied to subsequent batches of arguments from
 that vararg.  The \pr{table#5} primitive takes a vararg as its last
 argument.  For examples, see the \cref{tour} section and the \pr{apply#2}
 entry.

\par
 An \bf{even vararg} is a vararg with an even number of elements,
 An \bf{odd vararg} is a vararg with an odd number of elements.

\sec2{session}{Predefined session keys}

\begin{vbt}
   \\$device             \\: the session's output device
   \\$base               \\: the base name of the entry file
   \\$file               \\: the name of the file currently parsed
\end{vbt}

 This manual is littered with examples of the usage of \v{\\$device}.  The
 \v{\\$base} key is useful for creating sibling files of the entry file, i.e. a
 table of contents file or a file containing reference information.  I have the
 habit of naming those \v{\\$base.zmt} and \v{\\$base.zmr}, respectively.  The
 \v{\\$file} key is useful for emitting log, warning, or error messages.

\sec2{builtin}{Built-in macros}

\begin{vbt}
   \\def{input#1}{\\dofile{\\1}{!+}}
   \\def{import#1}{\\dofile{\\1}{!-}}
   \\def{read#1}{\\dofile{\\1}{?+}}
   \\def{load#1}{\\dofile{\\1}{?-}}
   \\def{refcaption#1}{\\ref{\\1}{c}}
   \\def{refnumber#1}{\\ref{\\1}{n}}
   \\def{reflevel#1}{\\ref{\\1}{l}}
   \\def{refmisc#1}{\\ref{\\1}{m}}
   \\def{reftype#1}{\\ref{\\1}{t}}
   \\def{string#1}{ifdef{\\1}{\\1}{}}
   \\def{inc#1}{\\ctradd{\\1}{1}}
   \\def{ctr#1}{\\ctrput{\\1}}
   \\def{ctr#2}{\\ctrset{\\1}{\\2}}
   \\def{"+"#2}{\\iclc{+}{\\1}{\\2}}
   \\def{"-"#2}{\\iclc{-}{\\1}{\\2}}
   \\def{"/"#2}{\\iclc{/}{\\1}{\\2}}
   \\def{"%"#2}{\\iclc{%}{\\1}{\\2}}
   \\def{"*"#2}{\\iclc{*}{\\1}{\\2}}
\end{vbt}

 Cf \pr{dofile#2}, \pr{ref#2}, \pr{ifdef#3}, \pr{ctradd#2}, \pr{ctrset#2},
 and \pr{iclc#3}.

\sec2{dictionary}{Dictionary stacks}

\par
 By default, when using \pr{def#2} and \pr{set#2}, keys and their values are
 put in a global user dictionary. It could be useful to shadow keys by
 entering a new scope. Zoem facilitates this by providing the \pr{push} and
 \pr{pop} keys. These push and pop a new dictionary onto the user dictionary
 stack.

\par
 A second dictionary stack is the \it{dollar dictionary stack}, which
 contains all keys that start with a dollar sign.  The user has no control
 over this stack.  The \pr{begin#1} primitive pushes a dollar dictionary each
 time it is invoked, and that dictionary is popped by the corresponding
 \pr{end#1} invocation.  This is typically useful for creating nested
 environments that need access to the same type of information - by storing
 such information in dollar keys, it can be shadowed and recovered.  Refer to
 the \pr{begin#1} entry.

\par
 When a key is used its definition is searched in all dictionaries,
 starting from the top-level dictionary.  \pr{ifdef#3} exhibits this
 behaviour as well. There is a specialized key \pr{ifdefl#3} that searches
 the top-level dictionary only.  The key \pr{undef#1} has only access to
 the top-level dictionary, and will never delete a key in any other
 dictionary. All these three keys work both on user keys and on
 dollar keys.

\sec1{tour}{A zoem tour}
\par
 What follows is an informal tour through zoem's offerings. The next
 section contains a comprehensive overview of the zoem primitives.

\par
 Let us start with how filtering in plain space is configured.
 An example was given above for a single device (namely html).
 A more realistic approach, used in the zoem man macros, is this.

\begin{vbt}
\\switch{\\$device}{
   {html}{
      \\special{
         {38}  {&amp;}
         {60}  {&lt;}
         {62}  {&gt;}
         {256} {&nbsp;}          \\: the zoem escape \\~
         {257} {<br>\\%N%}        \\: the zoem escape \\|
         {258} {-}               \\: the zoem escape \\-
      }
   }
   {roff}{
      \\special{
         {46}  {\\\\.}
         {96}  {\\\\`}
         {92}  {\\\\\\\\}            \\: a single backslash
         {256} {\\\\ }             \\: the zoem escape \\~
         {257} {\\%N%.br\\%N%}     \\: the zoem escape \\|
         {258} {\\\\-}             \\: the zoem escape \\-
      }
   }
   {\\write{stderr}{txt}{No such device: \\$device\\|}
    \\write{\\$base.err}{txt}{No such device: \\$device\\|}
    \\exit
   }
}
\end{vbt}

\par
 Take note of the number of backslashes. In order to print a backslash
 in troff, the troff input must contain two consecutive backslashes.
 In order to specify a backslash in zoem, we must also provide two,
 thus we need four backslashes in all (in order to create this example
 in the zoem input, I needed eight backslashes).

\par
 Also note the use of the \pr{switch#2} primitive, which takes
 an expression in the first argument and an arbitrary number of pairs plus an
 optional clause in the second argument. The optional clause was in this case
 used as a failure test.

\par
 \pr{special#1} is an example of a zoem key taking an argument that may
 contain arbitrarily many sub-arguments. In this particular case the
 sub-arguments must be paired, each pair defining how certain ascii
 characters that are special to the device must be represented.  There is a
 very limited number of additional tokens that can be mapped in this way:

\par
 The \pr{write#3} and \pr{exit} need little comment, they work as
 expected. Zoem opens output files as needed, and closes them when it is
 done. stdout and stderr work as you should expect, and '-' is equivalent to
 either \v{stdout} or \v{stdin}, depending on the context.
 The \pr{dofile#2} input primitive and its aliases
 \pr{input#1}, \pr{import#1}, \pr{read#1}, and \pr{load#1} (you
 may abhor if you wish) accept both
 \v{stdin} and '-' besides normal file names.

\par
 \pr{exit} is considered a failure (and will cause zoem to stop and
 complain), but \pr{quit} is not.  \pr{quit} will merely quit
 parsing the current stack, so if you specify it at top level in a file  \-
 not nested in a key that does its own parsing such as \pr{setx#2}, zoem
 will stop parsing the current file and transfer control back to the file
 from which it was included.

\par
 The previous example introduces the keys \v{\\$device} and
 \v{\\$base}. Together with \v{\\$file} they are a set of predefined
 keys that are private to a particular session.

\begin{vbt}
   \\$device             \\: the session's output device
   \\$base               \\: the base name of the entry file
   \\$file               \\: the name of the file currently parsed
\end{vbt}

\par
 A sibling primitive to \pr{special#1} is \pr{constant#1}. The
 following is an example of use.

\begin{vbt}
\\constant{
   {'e}  {&eacute;}     \\: Use e.g. as \\*'e*l\\*`e*ve (\*'e*l\*`e*ve)
   {(c)} {&copy;}       \\: Use e.g. as \\*(c)* DEEDEE (\*(c)* DEEDEE)
   {+-}  {&plusmn;}     \\: Use e.g. as \\*+-* a few (\*+-* a few)
}
\end{vbt}

 The main thing to note here is that the target string (e.g. \v{&eacute;})
 is \it{always interpreted in device space}.
 Inbetween the asterisks almost anything is allowed, except a backslash
 or a curly, and it is obviously not allowed to use an asterisk
 in one of the definition parts of \pr{constant#1}.

\par
 There are three zoem tokens representing the characters that have meaning to
 zoem syntax, the backslash and the two curlies.  Those zoem tokens are just
 like any other plain characters: they can be mapped in plain space, and they
 are printed literally in device space.

\begin{vbt}
   \\\\            \\: A backslash; possibly mapped in plain space.
   \\{            \\: A curly; possibly mapped in plain space.
   \\}            \\: A curly; possibly mapped in plain space.
   \\,            \\: The atomic separator (vanishes).
\end{vbt}

\par
 These tokens are mapped only during the (final) filter stage.
 The atomic separator can be useful when you want to glue together
 items some of which will be the result of macro expansion.

\begin{vbt}
   \\def{foo}{bar}
   \\foo\\,1                    \\: \\foo1 would be the key \\foo1
\end{vbt}

 This will result in bar1. The tokens \v{\\\\}, \v{\\\{}, and \v{\\\}}
 are really the corresponding ordinary ASCII characters.
 They can be mapped in plain space via \pr{special#1} using their
 ASCII values 92, 123, and 125 as was seen above for the backslash.
 In device space, they will result in \v{\\}, \v{\{}, and \v{\}}.

\par
 Let us now continue with device scope by implementing a \v{\\bf#1} key.
 Below you find two possible definitions:

\begin{vbt}
   \\def{bf}{1}{\\@{<b>} \\1 \\@{</b>}}    \\: Ok
   \\def{bf}{1}{\\@{<b> \\1 </b>}}        \\: Wrong! Wrong!
\end{vbt}

 The second is wrong because the contents of \v{\\1} end up in device
 space. If the expansion of \v{\\1} still contains keys they will not be
 expanded (and cause a fatal syntax error when device space is filtered),
 and additionally any special characters in \v{\\1} will not be
 mapped.

\sec1{language}{The zoem language}

\sec2{}{Alphabetic index}

\: this stuff constructs a 'Paragraph Of Contents'.
\${roff}{\write{stderr}{txt}{no support for roff device!}\exit}
\def{zzarg#1}{\{<\1>\}}
\formatted{
   \: third arg is a vararg in which all arguments of a key are stuffed.
   \def{zprim#3}
   {  
      \setx{keyref}{\ifeq{\2}{0}{\1}{\1#\2}}
      \setx{keysig}{\ifeq{\2}{0}{\v{\\\1}}{\v{\\\1#\2}}}
      \setx{keycall}{\ifeq{\2}{0}{}{:\~\~\v{\\\1\apply{zzarg#1}{\3}}}}
      \@{\%N%<a name="}\keyref\@{">\%N%}
      \@{\%N%</a>\%N%}
      \keysig\keycall
      \write{\$base.prm}{copy}
      {\@{\%N%<a href="#}\keyref\@{">\%N%}
         \keysig
       \@{\%N%</a>\%N%}\%n%
      }
   }
}
\def{zstr}{str}

\read{\$base.prm}

\sec2{}{Topic index}

\par
 This is an overlapping categorization in topics.

\begin{itemize}

\itemnew
\item{\bf{Applying and inspecting keys}}
\itemdef
   \pr{apply#2}
   \pr{constant#1}
   \pr{def#2}
   \pr{setx#2}
   \pr{ifdef#3}
   \pr{ifdefl#3}
   \pr{pop}
   \pr{push}
   \pr{set#2}
   \pr{store#2}
   \pr{table#5}
   \pr{undef#1}

\par
 These primitives affect \it{user keys} that are
 stored in the \lref{dictionary}{\it{user dictionary}}.
\itemend

\itemnew
\item{\bf{Control and composites}}
\itemdef
   \pr{$#2}
   \pr{apply#2}
   \pr{icmp#5}
   \pr{ifdef#3}
   \pr{ifdefl#3}
   \pr{ifeq#4}
   \pr{quit}
   \pr{switch#2}
   \pr{undef#1}
   \pr{while#2}
\itemend

\itemnew
\item{\bf{Expansion and meta-zoem}}
\itemdef
   \pr{setx#2}
   \pr{meta#3}
\itemend

\itemnew
\item{\bf{Input/output}}
\itemdef
   \pr{dofile#2}
   \pr{store#2}
   \pr{write#3}
\itemend

\itemnew
\item{\bf{Filtering}}
\itemdef
   \pr{special#1}
\itemend

\itemnew
\item{\bf{Scoped environments}}
\itemdef
   \pr{begin#1}
   \pr{end#1}
   \pr{env#3}
   \pr{pop}
   \pr{push}
\itemend

\itemnew
\item{\bf{Data}}
\itemdef
   \pr{dfree#1}
   \pr{dget#1}
   \pr{dprint#1}
   \pr{dset#2}
   \pr{dsetx#2}
\par
   These keys allow storage and retrieval of data in a tree
   where nodes are indexed by (arbitrary) strings.
\itemend

\itemnew
\item{\bf{Integers}}
\itemdef
   \pr{iclc#3}
   \pr{icmp#5}
   \pr{isum#1}
\itemend

\itemnew
\item{\bf{Counters}}
\itemdef
   \pr{ctradd#2}
   \pr{ctrput#1}
   \pr{ctrset#2}
\itemend

\itemnew
\item{\bf{References}}
\itemdef
   \pr{ref#2}
   \pr{refload#6}
\itemend

\itemnew
\item{\bf{Execution}}
\itemdef
   \pr{exit} \pr{trace#1}
\itemend

\itemnew
\item{\bf{Syntactic sugar}}
\itemdef
   \pr{formatted#1}
\itemend

\end{itemize}


\sec2{}{Primitives}
\begin{itemize}

\itemnew
\item{\zprim{$}{2}{{\zstr}{expr}}}
\itemdef
 This is a shortcut for activating output for a particular device.
 If \v{\\$device} expands to \zarg{\zstr}, \zarg{expr}
 is expanded, otherwise it is ignored.
 The following two are equivalent:

\begin{vbt}
\\${html}{Something only seen in the html device}

\\ifeq{\\$device}{html}{Something only seen in the html device}{}
\end{vbt}
\itemend

\itemnew
\item{\zprim{apply}{2}{{key-sig|anon-key}{vararg}}}
\itemdef
 \zarg{key-sig} is either of the form \v{foo#k} or \v{"bar::baz"#k} (i.e.
 the signature of any admissible user key), or it is a
 \lref{anonymous}{tagged anonymous key} (i.e. of the form \v{_#k{..}}) The
 second argument is first fully expanded, and should result in a vararg.
 The expansion makes it possible to ship a vararg in a key, or to
 concatenate two varargs using keys.  \pr{apply#2} extracts \v{k} elements
 at a time from \zarg{vararg}, and applies the key defined by
 \zarg{key-sig} to each vector of \v{k} elements successively.  Any
 elements remaining in \zarg{vararg} are ignored.  This:

\begin{vbt}
\\def{myfoo#2}{\\apply{\\1}{\\2}}
\\myfoo{_#2{\\1 says \\2\\|}}{{bill}{max}{will}{min}}
\end{vbt}

 works.
\itemend

\itemnew
\item{\zprim{begin}{1}{{label[<vararg>]}}}
\itemdef
 Expands the begin expression associated with \zarg{label} via
 \pr{env#3}. Label can optionally be followed by a \zarg{vararg}
 with any number of arguments inbetween 1 and 9.
 These arguments are accessible to the begin expression (as
 defined by \pr{env#3}) as the keys \v{\\$1} .. \v{\\$9}.
 The idea is that the environment can allow a user to specify
 arguments if he wants to, whereas it will provide default
 values for the undefined slots. This makes it possible for example to
 define a single \v{itemize} environment, that can be used as

\begin{vbt}
\\begin{itemize{custom}}             \\: implies use of \\$item#1 macro.
\\begin{itemize{bullet}}             \\: implies use of \\$item macro.
\\begin{itemize{custom}{compact}}    \\: no paragraph mode.
\\begin{itemize{roman}{default}{VI}} \\: start at 'VI'.
\end{vbt}

 The number of arguments that is present is stored in the key \v{\\$0} (note
 that it is not stored as a counter).  \pr{begin#1} pushes a new dictionary
 onto the dollar dictionary stack and the keys just mentioned live in this
 dictionary (which is popped by the matching \pr{close#1}). This means that
 nested \pr{begin#1} statements will work. It also means that the begin
 definition must use \pr{ifdefl#3} rather than \pr{ifdef#3} when it wants to
 check the definedness of its arguments \- the \v{\\$0} keys is always
 defined. Finally, it means that by associating dollar keys with an
 environment, these keys can be given different meanings in nested
 environments - the previous meaning will be restored once an environment is
 closed. The advantages are that the environment does not have to
 exercise \pr{push} and \pr{pop} itself, that the user dictionary stack
 is not unnecessarily extended (saving look-up time), and that
 the 'dollar' look of a key such as \v{\\$item} signals that it will
 automagically work in nested enviroments. Of course,
 the latter is still the responsibility of the author of the environment.

\par
 \bf{WARNING}\~\~zoem currently does not protect you from
 overwriting the \v{\\$0} .. \v{\\$9} keys. So just don't do that.

\par
 In the previous example, the begin definition would have to check whether
 \v{\\$1} is defined. If so, it would have to check its value (with
 \pr{switch#2} for example). If the value was \v{bullet}, it would have to
 define the \v{\\$item} with the appropriate value.  This dependency between
 \v{itemize}, \v{bullet} as a possible first argument, and the (required?)
 use of \v{\\$item} rather than \v{\\$item#1}, would be part of the \v{itemize}
 interface.  Obviously, there is some opportunity for subtle or not so subtle
 errors here, and the best remedy is well documented interfaces.
 A possible fragment of the itemize begin and end definitions could be

\begin{vbt}
\\formatted{
   \\def{$item}{ .. }       \\:   define a default.
   \\def{$item#1}{ .. }     \\:   define a default.
   \\env{itemize}{
      \\ifdefl{$1}{        \\:   e.g. custom|bullet|roman
         \\switch{\\$1}{
            {custom}{
               \\def{$item#1}{\\@{<dt>}\\1\\@{\\%N%}}
               \\@{<dl>\\%N%}              \\: starts the actual list.  
            }
            {bullet}{
               \\def{$item}{\\@{<li>\\@{\\%N%}}}
               \\@{<ul type=bullet>\\%N%}  \\: starts the actual list.  
            }
            {roman}{
               ..
               ..
            }
            {\\write{stderr}{txt}{itemize: \\$1 not a valid mode.\\|}}
         }
      }{    {\\@{<dl>\\%N%}}            \\: the default.
      }
      \\ifdefl{$2}{         \\:   e.g. compact|default
         ..
         ..
      }{}
   }
   {  \\ifdefl{\\$1}{
         \\switch{\\$1}{
            {custom}{\\@{</dl>\\%N%}}   \\: ends the actual list.
            {bullet}{\\@{</ul>\\%N%}}   \\: ends the actual list.
            {roman}{ .... }           \\: ends the actual list.
         }
      }{    {\\@{</dl>\\%N%}}           \\: the default.
      }
   }
}
\end{vbt}
\itemend

\itemnew
\item{\zprim{constant}{1}{{vararg}}}
\itemdef
 \zarg{vararg} must have an even number of arguments. These are
 interpreted as pairs. The first of each pair must enclose a string
 that does not contain any of the characters \v{*}, \v{\\},
 \v{\{}, or \v{\}}, say string \zarg{keystr}.
 The second encloses a string that will
 be interpreted in device space, say string \zarg{valstr}.
 When a sequence \v{\\*}\zarg{keystr}\v{*} is encountered, it
 is interpreted as \v{\\@\{}\zarg{valstr}\v{\}}. It is not
 allowed to use a sequence \v{\\*}\zarg{keystr}\v{*} in device scope,
 e.g. \v{\\@\{\\*}\zarg{keystr}\v{*\}} is illegal.
 See elsewhere in this manual for examples of usage.
\itemend

\itemnew
\item{\zprim{ctradd}{2}{{label}{expr}}}
\itemdef
 Add the expansion of \zarg{expr} to the counter associated with
 \zarg{label}.
\itemend

\itemnew
\item{\zprim{ctrset}{2}{{label}{expr}}}
\itemdef
 Set the counter associated with \zarg{label} to the expansion
 of \zarg{expr}.
\itemend

\itemnew
\item{\zprim{ctrput}{1}{{label}}}
\itemdef
 Put the counter associated with \zarg{label} in place.
\itemend

\itemnew
\item{\zprim{def}{2}{{key-sig}{expr}}}
\itemdef
 Bind second argument to the key in the first argument.  The second argument is
 evaluated (i.e. expanded) each time key is used.  This primitive will complain
 if a binding for that key exists already, but it will overwrite the previous
 binding and continue anyway.  Use \pr{set#2} if you do no want to be warned
 for overwriting.  Examples of usage:

\begin{vbt}
   \\def{foo}{FOO}
   \\def{foo#1}{The FOO of \\1}
   \\def{foo#2}{The FOO of \\1 and \\2}
   \\def{$foo#2}{The $FOO of \\1 and \\2}
   \\def{"foo::oof"#3}{\\foo{\\1}{\\2}\\foo{\\2}{\\3}}
\end{vbt}

\par
 See the \secref{macro} section for the forms that keys may take.  A key
 signature is the name of a key with appended to
 it the number of argument that the key takes, if any.  If the key takes no
 arguments, than the key signature is identical to the key name.
\itemend

\itemnew
\item{\zprim{setx}{2}{{key-sig}{expr}}}
\itemdef
 \zarg{expr} is expanded and stored in the key \zarg{key-name}.
 Besides simply storing the expansion of an expression, it can
 also be used to do trickier things as

\begin{vbt}
   \\def{bar}{klaas}
   \\setx{foo#2}{\\bar says \\1 and \\2}
   \\foo{x}{y}
   klaas says x and y
\end{vbt}

\par
 If you need lambda-like capabilities, take note that
 you can use \v{\\meta{k}{x}{}} to construct a positional parameter
 \v{\\k}, if you want to interpolate arguments into a key
 that will later take other arguments. Like this:

\begin{vbt}
   \\: is there any use for this wacky stuff?
   \\def{lambda#2}{\\setx{\\1#1}{\\2 says \\meta{1}{x}{}}}
   \\lambda{foo}{bar}
   \\foo{moo}
   bar says moo
\end{vbt}

\par
 Take care: the \pr{dofile#2} key outputs
 to the default output file. If you need to include the contents of
 a file within a \pr{setx#2} call, you need to use \pr{store#2}.
\itemend

\itemnew
\item{\zprim{dset}{2}{{vararg|expr}{expr|varag}}}
\itemdef
 \pr{dset#2} sets one or more values
 in a global multi-dimensional associative array that we shall
 refer to here as \vbt{ROOT}. Please note that \vbt{ROOT}
 is for explanatory purposes only. This associative array
 is best viewed as a tree, in which every node can have
 branches to higher nodes. A node may or may not contain
 a value. I denote the value contained by a node
 \v{some-node} as \v{*(some-node)}. The fact that
 \v{beta} is a node one branch higher than \v{alpha},
 which is in turn one branch higher than \v{ROOT}, is
 denoted as \v{ROOT->"alpha"->"beta"}. In this \it{path} notation,
 strings indexing nodes in the trees are written inbetween
 quotes. This has the advantage that the empty string, which is
 a valid index string, has the representation \v{""}.
 Combining these conventions, we write the value associated
 with \v{beta} as \v{*(ROOT->"alpha"->"beta")}.
 Consider these examples.

\begin{vbt}
   \\dset{{foo}{bar}{zut}}{lez}
   \\: now *(ROOT->"foo"->"bar"->"zut") is "lez"

   \\dset{{foo}{bar}{zut}}{{a}{b}{x}{y}}
   \\: now *(ROOT->"foo"->"bar"->"zut"->"a") is "b"
   \\: and *(ROOT->"foo"->"bar"->"zut"->"x") is "y"
   \\: and *(ROOT->"foo"->"bar"->"zut") still is "lez"

\\: some special cases
   \\dset{{foo}{bar}{zut}}{{{c}}}
   \\: now *(ROOT->"foo"->"bar"->"zut") is "{c}"
   \\dset{{foo}{bar}{zut}}{{c}}
   \\: now *(ROOT->"foo"->"bar"->"zut") is "c"
   \\dset{{foo}{bar}{zut}}{c}
   \\: now *(ROOT->"foo"->"bar"->"zut") is "c"

   \\dset{{foo}{bar}{zut}}{{c}{d}{e}}
   \\: This does nothing, because the second argument  must either
   \\: be an *even* vararg, a 1-element vararg, or a simple argument.

   \\dset{{{tiger}}}{in the woods}
   \\: now *(ROOT->"{tiger}") is "in the woods"
   \\dset{{tiger}}{in the woods}
   \\: now *(ROOT->"tiger") is "in the woods"
   \\dset{tiger}{on the loose}
   \\: now *(ROOT->"tiger") is "on the loose"
   \\: stripping curlies from a vararg with one argument does not make a
   \\: difference with the exception of the case shown below.

   \\dset{{}}{empty}
   \\: now *(ROOT->"") is "empty".
   \\dset{}{root}
   \\: now *(ROOT) is "root".
\end{vbt}

 Take note  of the rule  governing the  second argument. If  the first
 non-white space  character is  a left  curly, \pr{dset#2}  expects a
 vararg. The vararg must either be even or it must contain exactly
 \it{one} argument.

 An even vararg is interpreted as a sequence  of key-value pairs.
 Each key  induces a new branch  from the node specified  in the first
 argument, and  each value is associated  with the node at  the end of
 that branch.

 If the vararg contains exactly one argument, that argument is simply used as
 a value.  This is the only way to specify a block as the value.

 If the first non-white space character is not a curly, \pr{dset#2} will
 simply interpret the second argument as  a value  to append  to the node
 specified in  the first argument.

\itemend

\itemnew
\item{\zprim{dsetx}{2}{{vararg|expr}{expr|varag}}}
\itemdef
 The same as \pr{dset#2}, except that \pr{dsetx#2} expands the
 second argument before it is used for storing one or more values.
\itemend

\itemnew
\item{\zprim{dget}{1}{{vararg}}}
\itemdef
 \pr{dget#1} retrieves the value associated with \zarg{vararg},
 which denotes a path in the tree described in the \pr{dset#2} entry.
 Refer to that entry for more information.
\itemend

\itemnew
\item{\zprim{dprint}{1}{{vararg}}}
\itemdef
\pr{dprint#1} prints (to stdout) the subtree associated with \zarg{vararg},
 which denotes a path in the tree described in the \pr{dset#2} entry.  This
 can be used for debugging if your data manipulation does not work out as
 expected.  For printing the entire tree, use \v{\\dprint{}}.
 Refer to the \pr{dset#2} entry for more information.
\itemend

\itemnew
\item{\zprim{dfree}{1}{{vararg}}}
\itemdef
 \pr{dfree#1} frees the value and/or subtree associated with \zarg{vararg},
 which denotes a path in the tree described in the \pr{dset#2} entry.  For
 freeing the entire tree, use \v{\\dfree{}}.  Refer to the \pr{dset#2} entry
 for more information.

 \par I was tempted to name this key \v{\\dlet#1}, but then \v{\\dprint#1}
 would have been the odd one out. Then it occurred to me that
 renaming \v{\\dprint#1} as \v{\\djet#1}, would yield the ensemble
 \v{\\dset#2}, \v{\\dget#1}, \v{\\dlet#1}, and \v{\\djet#1}.
 But I let it go.
\itemend

\itemnew
\item{\zprim{dofile}{2}{{expr}{char[!?]><char[+-]}}}
\itemdef
 Open a file and include its contents. Depending on the second argument,
 absence of the file is either allowed or not, and its interpreted contents are
 output or not.  \zarg{expr} is first fully expanded until it contains no more
 keys.  This allows you to specify file names such as \v{\\$base.zyx}. This
 file is then opened according to the specification in the second argument.
 This argument must contain exactly two characters, the first one of [\v{!?}],
 the second one of [\v{+-}]. The first character indicates whether the file is
 allowed to be absent. A \v{!}' implies that absence is fatal, a '\v{?}'
 permits absence. The latter is useful e.g. when creating a Table Of Contents
 file.  The second character indicates whether the interpreted file should be
 filtered and output or not ('\v{+}' for yes and '\v{-}' for no). Macro
 packages typically need interpretation only, whereas concatenation of document
 parts (c.q. chapters) stored in different files requires that the interpreted
 content is also filtered and output.  The following aliases are available:

\begin{vbt}
\: alias             equivalent with
\\input{fname}        \\dofile{fname}{!+}
\\import{fname}       \\dofile{fname}{!-}
\\read{fname}         \\dofile{fname}{?+}
\\load{fname}         \\dofile{fname}{?-}
\end{vbt}
\itemend

\itemnew
\item{\zprim{end}{1}{{label[<vararg>]}}}
\itemdef
 Expands the end definition associated with \zarg{label} via \pr{env#3}.
 Within this definition, any arguments set by \pr{begin#1} are still
 visible (i.e. the \v{\\$0} .. \v{\\$9} keys). Additionally, \pr{end#1}
 accepts optional arguments just like \pr{begin#1} does. These are
 stored in \v{\\$0_} .. \v{\\$9_}. Check with \pr{ifdefl#3} whether an
 argument was given, and find the number of arguments in the \v{\\$0_} key.
 Again, zoem does not procect you from overwriting the \v{\\$0_} .. \v{\\$9_}
 keys. So just don't even if you must.
\itemend

\itemnew
\item{\zprim{env}{3}{{label}{expr1}{expr}}}
\itemdef
   Binds \zarg{expr1} and \zarg{expr2} to \zarg{label}, for
   use with \pr{begin#1} and \pr{end#1} respectively.
\itemend

\itemnew
\item{\zprim{exit}{0}{}}
\itemdef
goodbye world. This is a disgraceful exit for use when some error test yields
true.

\itemnew
\item{\zprim{formatted}{1}{{expr}}}
\itemdef
   This removes and adds white space from its arguments
   via the following rules:

   \begin{cblist}
   \@{<li>}
   It skips any \v{\\@{..}} enclosed sequence.
   \@{<li>}
   It removes all spaces, tabs, and newlines it encounters otherwise.
   \@{<li>}
   It inspects and (after inspection) removes all \v{\\%..%} enclosed
   sequences it encounters.  During inspection, \pr{formatted#1} maps
   '\v{s}' to a space, '\v{t}' to a tab, and '\v{n}' to a newline.
   
   Note that such sequences exist for a similar purpose in device scope, but
   device scope is skipped by \pr{formatted#1}.  The difference is that
   in device scope \v{\\%{..}} pertains to zoem output/device input, whereas
   \pr{formatted#1} modifies the input read by zoem.
   \end{cblist}

\par
 This is useful for writing legible macro files while exercising full control
 over whitespace (modulo Zoem's white space munging rules).
 For example, somewhere in the current man macros, in the definition of
 \v{\\section#3} the \pr{meta#3} primitive is used, which takes a
 \zarg{vararg} argument that becomes much more legible when spread over
 multiple lines.

\begin{vbt}
\\formatted{
   ....
   \\ifeq{\\1}{*}{}{
      \\write{\\$base.zmt}{copy}{
         \\meta{"man::tocentry"}{o}{
            {\\_ref}
            {1}
            {Section}
            {\\ctrput{man::sec}}
            {\\3}
            \\%n%
         }
      }
   }
   ...
}
\end{vbt}
   
 Side note: this writes an entry to the table of contents file, but
 it can be suppressed by supplying a \v{*} as the first argument
 to \v{\\sec#3}.
 The default key to use is \v{\\sec#2}, which always creates a
 TOC entry, and interprets \v{\\1} as a label for reference and
 \v{\\2} as the title of the section. Internally, the \v{\\sec#2}
 key is simply defined as

\begin{vbt}
   \\def{sec#2}{\\sec{}{\\1}{\\2}}
\end{vbt}

 If the user wants no TOC entry for a particular section, she
 simply uses \v{\\section{*}{someref}{Hide From TOC}}.
\itemend

\itemnew
\item{\zprim{iclc}{3}{{char[+-/%*]}{expr1}{expr2}}}
\itemdef
   Expands both \zarg{expr1} and \zarg{expr2}, interpretes the results as
   integers, applies the operand specified by \zarg{char}, and puts the
   result in place.
\itemend

\itemnew
\item{\zprim{icmp}{5}{{expr1}{expr2}{expr3}{expr4}{expr5}}}
\itemdef
   Expands \zarg{expr1} and \zarg{expr2}, interprets the results
   as integers, and compares them. Depending on the result,
   \it{less than}, \it{equal}, \it{greater than}, the corresponding
   expression from \zarg{expr3}, \zarg{expr4}, and \zarg{expr5}
   is evaluated.
\itemend

\itemnew
\item{\zprim{ifdef}{3}{{key-sig}{expr1}{expr2}}}
\itemdef
   If the key with signature \zarg{key-sig} exists in any scope,
   \zarg{expr1} is expanded, otherwise \zarg{expr2} is expanded.
\itemend

\itemnew
\item{\zprim{ifdefl}{3}{{key-sig}{expr1}{expr2}}}
\itemdef
   If the key with signature \zarg{key-sig} exists \it{in the top-level
   dictionary}, \zarg{expr1} is expanded, otherwise \zarg{expr2} is
   expanded.
\itemend

\itemnew
\item{\zprim{ifeq}{4}{{expr1}{expr2}{expr3}{expr4}}}
\itemdef
   \zarg{expr1} and \zarg{expr2} are expanded (not filtered),
   and then string compared. If they are equal, \zarg{expr3} is expanded
   (and \zarg{expr4} ignored), otherwise \zarg{expr4} is expanded.
\itemend

\itemnew
\item{\zprim{isum}{1}{{vararg}}}
\itemdef
   Expands all elements in \zarg{vararg}, interprets the results
   as integers and puts the sum of those in place.
\itemend

\itemnew
\item{\zprim{meta}{3}{{key-name}{modifiers}{vararg}}}
\itemdef

   \pr{meta#3} constructs a zoem key call (i.e. simply a key being used) from
   the first and last arguments. The first argument is expanded. The result
   should either be the name of a key or an \lref{anonymous}{anonymous key}.
   The last argument is a \zarg{vararg}, each element of which is concatenated
   as an argument to the key name. \bf{NOTE} currently no whitespace is allowed
   inbetween (delimiting curlies of) the subarguments contituting the vararg.

\par
   This is used for creating zoem instructions that must be read in at a
   later time. A typical usage is in creating Table Of Contents files and
   reference files, i.e. files containing bindings between labels and section
   numbers or page numbers.  See the \pr{formatted#1} entry for example of
   usage.

\par
   The second argument may contain flags (in the form of characters) telling
   zoem what to do.  If the first character equals \v{x}, zoem will push the
   result of \pr{meta#3} onto the stack for expansion. If it equals \v{o}, zoem
   will flush the result to the active filter routine (\v{o} for output).

\par
   The second argument will probably allow finer control in the near future.
   Two particular items I am considering are i) allowing for each
   argument to be specified whether it should be expanded or not and ii)
   introducing a new expansion mode tentatively called \v{skim}, that
   expands linearly rather than recursively.
   A concrete example of such usage would be

\begin{vbt}
   \\meta{\\foo}{p,xslssx}{{x1}{x2}{x3}{x4}{x5}{x6}}
\end{vbt}

   Where \v{p} is as previously discussed, and where \v{l}, \v{s}, and \v{x}
   respectively mean \it{leave alone}, \it{skim}, and \it{expand}.
   In this example, \v{x1} and \v{x6} would be expanded, \v{x2}, \v{x4},
   and \v{x5} would be skimmed, and \v{x3} would be left alone, before
   the key call of \v{foo} is constructed.

\par
   \pr{meta#3} can also be used to construct positional parameters.
   See the \pr{setx#2} entry for an example.
\itemend

\itemnew
\item{\zprim{pop}{0}{}}
\itemdef
   Pops a dictionary from the user dictionary stack.
\itemend

\itemnew
\item{\zprim{push}{0}{}}
\itemdef
   Pushes a new dictionary onto the user dictionary stack.  Note that
   \pr{ifdefl#3} checks only the top-level dictionary, whereas \pr{ifdef#3}
   checks the whole stack of dictionaries.  Also, \pr{undef#1} only removes a
   key from the top-level dictionary. There is currently not a way to remove a
   key from all dictionaries.

\par
   Example of usage:

\begin{vbt}
\\def{num}{1}
\\push
   \\def{num}{2}
   \\push
      \\def{num}{3}
      \\push
         \\def{num}{4}
      \\pop
      num is \\num
   \\pop
   num is \\num
\\pop
num is \\num
\end{vbt}

   results in

\begin{vbt}
num is 3
num is 2
num is 1
\end{vbt}
\itemend

\itemnew
\item{\zprim{quit}{0}{}}
\itemdef
   Quit parsing current stack. If encountered in a file at top level,
   i.e. not nested in a key that does its own parsing such as \pr{setx#2},
   it simply terminates file interpretation at that point. And these are
   equivalent:

\begin{vbt}
\\setx{foo}{\\bar begat \\baz\\quit bla boo dee}
\\setx{foo}{\\bar begat \\baz}
\end{vbt}
\itemend

\itemnew
\item{\zprim{ref}{2}{{\zstr}{char[ltncm]}}}
\itemdef
   Put one of the fields associated with the label \zarg{\zstr}
   in place.  The second argument is a single character identifying
   the field to retrieve.  Use \bf{l} for the level field, \bf{t} for the
   type field, \bf{n} for the number field, \bf{c} for the caption field,
   and \bf{m} for the misc field.
\itemend

\itemnew
\item{\zprim{refload}{6}{{x.r}{x.l}{x.t}{x.n}{x.c}{x.m}}}
\itemdef
   [\v{x} is short for expression here]
   \zarg{x.r} (r for ref) is the label with which the other elements can
   later be retrieved. The other elements stand for \it{level}, \it{type},
   \it{number}, \it{caption}, and \it{misc}.  For a section, these could for
   example be \v{3}, \v{Section}, \v{6.2.1}, \v{How to peel potatoes},
   \v{this field not used}.  This primitive is clearly meant for making
   indexing and table of content macros. See the
   \cref{anatomy} section for an example of usage.
\itemend

\itemnew
\item{\zprim{set}{2}{{key-sig}{expr}}}
\itemdef
   As \pr{def#2} above, except that \pr{set#2} will not complain
   if the key labeled by \zarg{key-sig} already exists.
\itemend

\itemnew
\item{\zprim{special}{1}{{vararg}}}
\itemdef
   \zarg{vararg} must have an even number of arguments.  These are
   interpreted as pairs. The first of each pair must enclose an integer in
   the range 0-258.  The first 256 integers in this range are interpreted as
   character indices according to the ASCII (American Standard Code for
   Information Interchange) standard.  The characters indexed 256, 257, and
   258 correspond with the zoem glyphs \v{\\~}, \v{\\|}, and \v{\\-}
   respectively.  The second element in each pair defines the string to
   which the character specified by the first element must be mapped.  This
   string is interpreted in device scope.  See the
   \cref{hello} and \cref{dscope}
   sections.
\itemend

\itemnew
\item{\zprim{store}{2}{{key-name}{expr}}}
\itemdef
   \zarg{expr} is expanded and used as a file name. This file is opened, and
   its contents are directly stored in \zarg{key-name}, which must be a key
   taking no arguments.  Absence or failure of opening the file is \it{not}
   fatal. In that case, the empty string is stored in the key.
\itemend

\itemnew
\item{\zprim{switch}{2}{{expr}{vararg}}}
\itemdef
   \zarg{expr} is expanded. Subsequently, two arguments are
   successively taken from \zarg{vararg}. The first is expanded
   and string compared with \zarg{expr}. If they match, the
   second argument is expanded and everything else is ignored.
   If they do not match, the procedure is repeated.
   If no (odd) argument matches, and the \zarg{vararg} has an odd
   number of arguments, the last argument is expanded. It
   can be considered a failure clause.
\itemend

\itemnew
\item{\zprim{table}{5}{{expr1}{expr2}{expr3}{expr4}{vararg}}}
\itemdef
   \zarg{expr1} is expanded and interpreted as an integer, say \v{k}.
   Successively, vectors of \v{k} elements are shifted from
   \zarg{vararg}. Each vector is bordered on the left with
   \zarg{expr2}, bordered on the right with \zarg{expr4}, and
   all elements in the vector are separated with \zarg{expr3}.
\itemend

\itemnew
\item{\zprim{trace}{1}{{expr}}}
\itemdef
   \zarg{expr} is expanded and interpreted as an integer.
   This integer encodes an ensemble of flags controlling
   the trace output. The different modes are exactly the
   same as those that can be set from the command line.
   Refer to the \lref{cline}{corresponding section} for more information.
   Special values are
   \v{0} (switch off all tracing),
   \v{-1} (switch on all tracing modes in short mode),
   \v{-2} (switch on all tracing modes in long mode),
   and \v{-3} (switch to the previous tracing value).
   It can be useful to switch tracing on for a short while and then off again
   if you need to debug your document.
\itemend

\itemnew
\item{\zprim{undef}{1}{{key-sig}}}
\itemdef
   Deletes the key with signature \zarg{key-sig} from the
   top level dictionary. Complains (but does not fail) if the key
   does not exist in that dictionary.
\itemend

\itemnew
\item{\zprim{while}{2}{{expr1}{expr2}}}
\itemdef
   While \zarg{expr1} exands to something that is nonzero when
   interpreted as an integer, \zarg{expr2} is expanded and put
   in place. The following piece of zoem asks the user for
   an integer and writes all Fibonacci numbers smaller than that
   integer to stdout.

\begin{vbt}
\\def{fib#1}{
   \\ctr{a}{1}
   \\ctr{b}{1}
   \\while{\\icmp{\\ctr{a}}{\\1}{1}{1}{a}}{
      \\ctr{c}{\\ctr{a}}
      \\ctr{a}{\\"+"{\\ctr{a}}{\\ctr{b}}}
      \\write{stdout}{txt}{\\ctr{c}\\|}
      \\ctr{b}{\\ctr{c}}  \\:  txt filter maps \\| to newline
   }
}

\\write{-}{txt}{Enter a number please, then press <cr> and <ctl-d>\\|}
\\store{num}{-}    \\:  this reads from stdin.
\\fib{\\num}
\end{vbt}

\par
   Warning: the strings built up by \pr{while#2} are internally concatenated
   until it is done. This will make \pr{while#2} work for \pr{setx#2}.  If
   you want to output 100M worth of lines or paragraphs in a while loop, embed
   the stuff to be output in a \pr{write#3} call.
\itemend

\itemnew
\item{\zprim{write}{3}{{expr1}{\zstr}{expr2}}}
\itemdef
   The first argument \zarg{expr1} is expanded and used as a file name.  It is
   a fatal error if the file cannot be opened for writing.  Two special file
   names or 'streams' are recognized, namely \v{stdout} and \v{stderr}. They
   map to stdout and stderr.  The third argument \zarg{expr2} is expanded,
   filtered, and written to file.  The second argument indicates the filter to
   be used. It must be one of the (literal) strings \v{copy}, \v{device}, or
   \v{txt}.

   The \v{copy} filter does not filter anything at all (neither plain scope
   nor device scope) and does not touch any of the zoem escape sequences
   remaining after expansion.

   The \v{device} filter does a full-fledged filtering of both scopes.
   It respects the settings according to the \pr{special#1}
   primitive.

   The \v{txt} filter maps \v{\\\\} to \v{\\} (i.e. a single
   backslash), \v{\\~} to a single space, \v{\\-} to a single hyphen,
   \v{\\,} (the atomic separator) to nil, \v{\\|} to a newline,
   \v{\\\{} to \v{\{}, and \v{\\\}} to \v{\}}. It copies everything
   else verbatim.
\itemend

\end{itemize}

\sec1{manexample}{The zoem manual macros}

\par
 This section contains a manual page for the fictitious \it{buzz} utility.
 Several things are shown, including references to options and sections
 that show up as hyperlinks in html, while resulting in normal text
 in troff.  This requires some authoring discipline, as one has to write
 the text such that it makes sense in the absence of hyperlinks.
 This section contains the following subsections:

\begin{itemize}
   \citem{\lref{manlisting}{\refnumber{manlisting}}}
   \itemdef  \lref{manlisting}{\refcaption{manlisting}}
   \citem{\lref{manzoem}{\refnumber{manzoem}}}
   \itemdef  \lref{manzoem}{\refcaption{manzoem}}
   \citem{\lref{manhtml}{\refnumber{manhtml}}}
   \itemdef  \lref{manhtml}{\refcaption{manhtml}}
   \citem{\lref{manps}{\refnumber{manps}}}
   \itemdef  \lref{manps}{\refcaption{manps}}
\end{itemize}

\par
 The \it{buzz} manual page is shipped with the zoem source, as are the
 manual macros. They are in a file called \v{man.zmm}.

\sec2{manlisting}{A list of the zoem manual macros}

\par
 This is a list of the macros supplied by the
 \: hierverder: mq: link to the package.
 zoem manual macro package. There are idiosyncrasies in the names chosen, and
 the provided functionality does not cover every need.  Change, improve, and add
 as you like.  \lref{comments}{Somewhat below} you will find the buzz manual
 page and the usage of the manual macros commented.

\begin{itemize}

\itemnew
\item{\bf{Type face macros}}
\itemdef
   \vbt{\\bf#1  \\it#1  \\tt#1  \\vbt#1}

   \par The presence of both \v{\\tt#1} and \v{\\vbt#1} is
   a bit idiosyncratic. The first maps to \v{<tt>} in html
   and the last maps to \v{<code>}. There is no difference
   between the two in troff.
\itemend

\itemnew
\item{\bf{Meta data keys macros}}
\itemdef
   \vbt{\\"man::year" \\"man::month" \\"man::day" \\"man::name"
   \\"man::html-title" \\"man::author" \\"man::section" \\"man::version"}

   \par These must be given reasonable values, lest you will for example see
   \v{a*u*t*h*o*r} occur somewhere.
\itemend

\itemnew
\item{\bf{Necessary evils}}
\itemdef
   \vbt{\\"man::preamble"  \\"man::postamble"}

   \par The \v{\\"man::preamble"} key uses the meta data keys above.
   It also reads in the file containing references (\v{\\$base.zmr})
   and the file containing the table of contents information
   (\v{\\$base.zmt}).
\itemend

\itemnew
\item{\bf{Sectioning macros}}
\itemdef
   \vbt{\\"man::maketoc" \\sec#2  \\secref#1 \\par}

   \par Only one level of section nesting is supported. It would not be hard to
   support more levels, but I decided to stick to the classic style manual
   page. The \v{\\"man::maketoc"} does work in troff, and I use it there when
   the manual page has unusual section headers. In html I always create a table
   of contents, as it is conveniently linked to the sections.
\itemend

\itemnew
\item{\bf{Environment macros}}
\itemdef
   \vbt{itemize} environment, \v{\\itemnew  \\item#1  \\itemdef  \\itemend}\|
   The \vbt{vbt} and \vbt{vbtbl} environments.

   \par
   There are so many \v{item} related keys because the spacing and
   layout of lists is a mess in various html interpreters, and because
   it is a difficult issue anyway.

   \par
   The \v{vbt} environment is for rendering text \v{verbatim} style (example
   below).  The \v{vbtbl} environment does the same, except that it will (in
   troff) not split the contents over two pages - it will start a new page if
   the 'table' does not fit on the current page.
\itemend

\itemnew
\item{\bf{Option related macros}}
\itemdef
   \vbt{\\synoptopt#3  \\synoptopt#2  \\synreqopt#3  \\synreqopt#2
   \\defopt#3 \\defopt#2
   \\genopt#2  \\genopt#1  \\genarg#1  \\useopt#2  \\useopt#1  \\usearg#1
   \\"man::synstyle"  \\"man::defstyle"}

   \par The usage of these keys is described in the section
   \lref{comments}{\refcaption{comments}}.
\itemend

\itemnew
\item{\bf{Miscellaneous macros}}
\itemdef
   \vbt{\\httpref#1  \\sibref#2}
\itemend
\end{itemize}

\sec2{manzoem}{An example zoem manual page}

\hrule
\begin{vbt}
\\def{"man::synstyle"}{long}
\\def{"man::defstyle"}{long}
\\import{man.zmm}

\\: customized command for the synopsis section.
\\def{fileopt#2}{\\bf{\\1} (\\it{\\2})}

\\set{"man::year"}{2002}
\\set{"man::month"}{Feb}
\\set{"man::day"}{4}
\\set{"man::name"}{buzz}
\\set{"man::html-title"}{What's the buzz}
\\set{"man::author"}{Stijn van Dongen}
\\set{"man::section"}{1}
\\set{"man::version"}{1.00}

\\"man::preamble"
\\${html}{\\"man::maketoc"}

\\def{buzz}{\\bf{buzz}}

\\sec{name}{NAME}
   \\par
   buzz \\- go buzz.

\\sec{synopsis}{SYNOPSIS}
   \\par
   \\buzz
      \\synreqopt{-l}{i}{loudness}
      \\synreqopt{-d}{f}{duration}
      \\synoptopt{-f}{f}{frequency}
      \\synoptopt{--dragonfly}{dragon style}
      \\synoptopt{--bumblebee}{bumble style}
      \\synoptopt{--disk}{computer style}
      \\synoptopt{-style}{some style}
      \\synoptopt{--scan}{scan mode}
      \\fileopt{<file.bzz|dir>}{tune source}

\\sec{description}{DESCRIPTION}

\\par
   \\buzz buzzes. It can do so in different styles, at different base
   frequencies, and at different volumes. See the \\secref{options} section
   for a description of all options.

\\par
   The \\optref{-l}{\\genopt{-l} option} and \\optref{-d}{\\genopt{-d} option}
   are both mandatory. The last argument given must be a file containing
   the tune to buzz, or a directory containing such tune files.
   The tune must be contained in an interval of at most
   five tones. Non-conforming tunes may damage your soundcard.

\\sec{options}{OPTIONS}

\\begin{itemize}

   \\itemnew
   \\item{\\defopt{-f}{f}{frequency}}
   \\itemdef
      Frequency in Hertz, can be specified as a positive real number.
   \\itemend

   \\itemnew
   \\item{\\defopt{-l}{i}{loudness}}
   \\itemdef
      Loudness, which is specified as an integer inbetween 0 and 100.
   \\itemend

   \\itemnew
   \\item{\\defopt{-d}{f}{duration}}
   \\itemdef
      Duration in hours, can be specified as a positive real.

      \\par
      The following options are discussed as a group:
   \\itemend

   \\itemnew
   \\item{\\defopt{--dragonfly}{dragon style}}
   \\itemend

   \\itemnew
   \\item{\\defopt{--bumblebee}{bumble style}}
   \\itemend

   \\itemnew
   \\item{\\defopt{--mosquito}{sting style}}
   \\itemend
   \\itemdef
      These are unary options specifying the style in which to buzz.
   \\itemend

   \\itemnew
   \\item{\\defopt{-style}{str}{buzz style}}
   \\itemdef
      \\genarg{str} should be one of \\vbt{bumble}, \\vbt{dragon}, or
      \\vbt{mosquito}.
   \\itemend

   \\itemnew
   \\item{\\defopt{--scan}{scan mode}}
   \\itemend
   \\itemdef
      This will buzz 10 seconds for each tune specified.
      Refer also to the \\optref{-sd}{\\genopt{-sd} option}.
   \\itemend

   \\itemnew
   \\item{\\defopt{-sd}{i}{scan duration}}
   \\itemend
   \\itemdef
      Sets the scan time in (an integer number of) seconds. This affects the
      \\optref{--scan}{\\genopt{--scan} option}.
   \\itemend
\\end{itemize}


\\sec{files}{FILES}
\\par
   /etc/zoem/foriamzoem.bzz contains the zoem jingle.\\|
   /etc/zoem/zoem.ascii-art contains zoem related ascii art.
   An excerpt is shown below.

\\begin{vbtbl}
.-----------------------------.
|                             |                    
|                  _ " _      |                          
|     (\\"/)       (_\\|/_)     |                              
|     (/|\\)       (_/|\\_)     |                             
|       |            |        |                            
|             ()     |        |                                
|          -----%             |                        
|             ()              |                       
|                          ejm|
.-----------------------------.
\\end{vbtbl}

\\sec{environment}{ENVIRONMENT}
\\par
   Currently, no environmental issues with \\buzz.

\\sec{diagnostics}{DIAGNOSTICS}
\\par
   If the tune spans an interval larger than 5 tones, buzz will
   emit little beeps. If the interval exceeds an octave, buzz
   will fork and exec \\bf{bell}.

\\sec{bugs}{BUGS}
\\par
   Some do.

\\sec{author}{AUTHOR}
\\par
   Bugs Bunny.

\\sec{history}{HISTORY}
\\par
   repeats itself, especially from a buzzing point of view.

\\sec{seealso}{SEE ALSO}

\\par
   \\sibref{bell}{1}.
\\${html}{This reference is not going anywhere; it just demonstrates
a way of implementing references to other utilities. Troff can not link anyway,
so this warning is strictly html.}

\\${html}{\\par
On the www it is difficult to show a manual page as compiled for rendering in a
terminal, but one can view a manual page as compiled for rendering by a
postscript interpreter.
Lo and behold \\httpref{buzz.ps}.}

\\par
\\httpref{http://www.google.com/search?hl=en&q=zoem+macro} .

\\"man::postamble"
\end{vbt}

\sec2{manhtml}{What it looks like in html}

\hrule

\@{\%w%
<div class=indent>

<p style="text-align:right">
4 Feb 2002&nbsp;&nbsp;&nbsp;<b>buzz</b> version 1.00
</p>
<dl compact>
<dt>1.<dd><a href="#name">NAME</a>
<dt>2.<dd><a href="#synopsis">SYNOPSIS</a>
<dt>3.<dd><a href="#description">DESCRIPTION</a>
<dt>4.<dd><a href="#options">OPTIONS</a>
<dt>5.<dd><a href="#files">FILES</a>
<dt>6.<dd><a href="#environment">ENVIRONMENT</a>
<dt>7.<dd><a href="#diagnostics">DIAGNOSTICS</a>
<dt>8.<dd><a href="#bugs">BUGS</a>
<dt>9.<dd><a href="#author">AUTHOR</a>
<dt>10.<dd><a href="#history">HISTORY</a>
<dt>11.<dd><a href="#seealso">SEE ALSO</a>
</dl>

<a name="name"></a>
<h2>NAME</h2>

<p>
buzz - go buzz.

<a name="synopsis"></a>
<h2>SYNOPSIS</h2>

<p>
<b>buzz</b>
<a href="#opt-l"><b>-l</b> i (<i>loudness</i>)</a>
<a href="#opt-d"><b>-d</b> f (<i>duration</i>)</a>
<a href="#opt-f"><b>[-f</b> f (<i>frequency</i>)<b>]</b></a>
<a href="#opt--dragonfly"><b>[--dragonfly</b> (<i>dragon style</i>)<b>]</b></a>
<a href="#opt--bumblebee"><b>[--bumblebee</b> (<i>bumble style</i>)<b>]</b></a>
<a href="#opt--disk"><b>[--disk</b> (<i>computer style</i>)<b>]</b></a>
<a href="#opt-style"><b>[-style</b> (<i>some style</i>)<b>]</b></a>
<a href="#opt--scan"><b>[--scan</b> (<i>scan mode</i>)<b>]</b></a>
<b>&lt;file.bzz|dir&gt;</b> (<i>tune source</i>)

<a name="description"></a>
<h2>DESCRIPTION</h2>

<p>
<b>buzz</b> buzzes. It can do so in different styles, at different base
frequencies, and at different volumes. See the
<a href="#options">OPTIONS</a> section
for a description of all options.

<p>
The <a href="#opt-l"><b>-l</b> option</a> and <a href="#opt-d"><b>-d</b> option</a>
are both mandatory. The last argument given must be a file containing
the tune to buzz, or a directory containing such tune files.
The tune must be contained in an interval of at most
five tones. Non-conforming tunes may damage your soundcard.

<a name="options"></a>
<h2>OPTIONS</h2>

<dl compact>
<dt><a name="opt-f"></a><b>-f</b> f (<i>frequency</i>)
<dd>
Frequency in Hertz, can be specified as a positive real number.
<br>
<br>
<dt><a name="opt-l"></a><b>-l</b> i (<i>loudness</i>)
<dd>
Loudness, which is specified as an integer inbetween 0 and 100.
<br>
<br>
<dt><a name="opt-d"></a><b>-d</b> f (<i>duration</i>)
<dd>
Duration in hours, can be specified as a positive real.

<p>
The following options are discussed as a group:
<br>
<br>
<dt><a name="opt--dragonfly"></a><b>--dragonfly</b> (<i>dragon style</i>)
<br>
<br>
<dt><a name="opt--bumblebee"></a><b>--bumblebee</b> (<i>bumble style</i>)
<br>
<br>
<dt><a name="opt--mosquito"></a><b>--mosquito</b> (<i>sting style</i>)
<br>
<br>
<dd>
These are unary options specifying the style in which to buzz.
<br>
<br>
<dt><a name="opt-style"></a><b>-style</b> str (<i>buzz style</i>)
<dd>
<i>str</i> should be one of <code>bumble</code>, <code>dragon</code>, or
<code>mosquito</code>.
<br>
<br>
<dt><a name="opt--scan"></a><b>--scan</b> (<i>scan mode</i>)
<br>
<br>
<dd>
This will buzz 10 seconds for each tune specified.
Refer also to the <a href="#opt-sd"><b>-sd</b> option</a>.
<br>
<br>
<dt><a name="opt-sd"></a><b>-sd</b> i (<i>scan duration</i>)
<br>
<br>
<dd>
Sets the scan time in (an integer number of) seconds. This affects the
<a href="#opt--scan"><b>--scan</b> option</a>.
<br>
<br>
</dl>

<a name="files"></a>
<h2>FILES</h2>

<p>
/etc/zoem/foriamzoem.bzz contains the zoem jingle.<br>
/etc/zoem/zoem.ascii-art contains zoem related ascii art.
An excerpt is shown below.

<pre>
.-----------------------------.
|                             |                    
|                  _ " _      |                          
|     (\\"/)       (_\\|/_)     |                              
|     (/|\\)       (_/|\\_)     |                             
|       |            |        |                            
|             ()     |        |                                
|          -----%             |                        
|             ()              |                       
|                          ejm|
.-----------------------------.
</pre>

<a name="environment"></a>
<h2>ENVIRONMENT</h2>

<p>
Currently, no environmental issues with <b>buzz</b>.

<a name="diagnostics"></a>
<h2>DIAGNOSTICS</h2>

<p>
If the tune spans an interval larger than 5 tones, buzz will
emit little beeps. If the interval exceeds an octave, buzz
will fork and exec <b>bell</b>.

<a name="bugs"></a>
<h2>BUGS</h2>

<p>
Some do.

<a name="author"></a>
<h2>AUTHOR</h2>

<p>
Bugs Bunny.

<a name="history"></a>
<h2>HISTORY</h2>

<p>
repeats itself, especially from a buzzing point of view.

<a name="seealso"></a>
<h2>SEE ALSO</h2>

<p>
<a href="bell.html">bell</a>.
This reference is not going anywhere; it just demonstrates
a way of implementing references to other utilities. Troff can not link anyway,
so this warning is strictly html.

<p>
On the www it is difficult to show a manual page as compiled for rendering in a
terminal, but one can view a manual page as compiled for rendering by a
postscript interpreter.
Lo and behold <a href="buzz.ps">buzz.ps</a>.

<p>
<a href="http://www.google.com/search?hl=en&amp;q=zoem+macro">
http://www.google.com/search?hl=en&amp;q=zoem+macro</a> .
\%W%
</div>
}

\sec2{manps}{What it looks like as PostScript generated from troff}

\par
 A link to the PostScript version of the manual page was provided in the buzz
 document itself and \href{buzz.ps}{here is another one}.  Note that this
 PostScript was compiled by groff from the troff output that was compiled by
 zoem from the zoem input.

\sec2{comments}{Comments on writing zoem manual pages}

\par
 There are several things to note.

\par
 The \v{\\synoptopt#3} and \v{\\synreqopt#3} macros (for optional and
 required options respectively) assume that somewhere a tag
 exists (for the option to which they refer) which is created by
 \v{\\defopt#3}.
 The tag is simply the option itself \- with hyphens included.
 It is used to create hyperlinks in the html output.  This  introduces a fine
 point of writing manual pages using zoem \- you should write them so that
 the text is comprehensible either in the presence or absence of hyperlinks.
 A family of sibling keys \v{\\synoptopt#2}, \v{\\synreqopt#2},
 \v{\\defopt#2} exists. The \v{#3} family is for describing options
 that take arguments, the \v{#2} family is for options that do not
 take an argument.

\par
 The third argument of \v{\\synoptopt#3} (and \v{\\synreqopt#3}) must contain
 a short descriptive string describing the functionality supplied by the
 option. If the key \v{\\"man::synstyle"} is set to the value
 \v{long} this information will be printed; if it is set to \v{short} it will
 be ignored.  \v{\\defopt#3} is used for creating entries for options that
 take arguments, and \v{\\defopt#2} is used for entries for options that do
 not.  The last argument of both is again a descriptive string, which is shown
 or not shown depending on the value of \v{\\"man::defstyle"}.

\par
 There are no special keys for typesetting file arguments or, in general,
 arguments for which the meaning depends on their position.
 You have to devise your own habits, rules, and macros for that.
 In the example above, I simply typeset the file argument in boldface.

\par
 For creating references to options, the manual macros provide the
 \v{\\optref#2} key (which is also used by the \v{\\synoptopt} family).
 It takes a tag (which is simply the option) as its first
 argument, and the text which forms the link as the second.  Consider the
 following piece quoted from the example.

\begin{vbt}
   Sets the scan time in (an integer number of) seconds. This affects
   the \\optref{--scan}{\\genopt{--scan} option}.
\end{vbt}

 The main thing to note is that the text is very explicit about that to
 which it refers. This will make it comprehensible when no links are present.
 It would clearly be a bad idea to write

\begin{vbt}
   Sets the scan time in (an integer number of) seconds. See also
   \\optref{--scan}{this option}.
\end{vbt}

 Note also the use of \v{\\genopt#2} in the example further above.  I have a
 habit of trying to label the different ways in which the text refers to
 options, so that I can make those different uses stand out visually if I
 want to. However, nothing stops you from using

\begin{vbt}
   Sets the scan time in (an integer number of) seconds. This affects
   the \\optref{--scan}{\\bf{--scan} option}.
\end{vbt}

 instead; it is a matter of style and preference.
 \v{\\genopt#1} stands for 'generic' (mention of option). There is a variant
 \v{\\genopt#2} in which the argument to an option is also given, as a
 \it{generic} argument, i.e. \it{float} rather than \v{5.0} and \it{str}
 rather than \v{ponytail}. Another variant is \v{\\genarg#1} and the
 counterparts to all of these are \v{\\useopt#2} and \v{\\useopt#1} and
 \v{\\usearg#1}.

\par
 Take special note of the \v{\\secref#1} primitive.  It takes a label as its
 first argument. The label must have been used elsewhere as the first
 argument to \v{\\sec#2}, and \v{\\secref#1} outputs the title of that section
 (using the \v{\\refcaption} alias). It will be linked to the corresponding
 section in html. This requires a certain style of writing as well, you must
 be aware that a caption (header, title) is inserted in the text. These are
 the respective definitions of \v{\\secref#1} in html and troff:

\begin{vbt}
   \\: html
      \\def{secref#1}{
         \\@{\\%N%<a href="#\\1">}
         \\refcaption{\\1}
         \\@{</a>}
      }
   \\: troff
      \\def{secref#1}{\\bf{\\refcaption{\\1}}}
\end{vbt}

\:  mq make a concise list.
\:  itemize is rather verbose. (ie, netscape).
\:  optref requires a certain style of writing.
\:  href vs httpref?
\:  synopsis hacking.
\:  vbtbl and vbt.

\sec1{anatomy}{Zoem manual macros dissected}
\par
 The zoem manual macro package defines \v{\\sec#2} and \v{\\sec#3} keys that
 are a little involved, as they contain instructions to write to a table of
 contents (toc) file (that is read in somewhere else).  The \v{\\sec#2} key
 is what I mostly use. It wraps around the \v{\\sec#3} key, of which the
 first parameter indicates whether the section should be included in a toc or
 not.  The convention used is that \v{*} indicates no toc entry should be
 made, anything else will result in a toc entry.

\par
 The second (first) argument of \v{\\sec#3} (\v{\\sec#2}) is an anchor which
 can be used as a reference to the section.  If this argument is empty,
 \v{\\sec#3} will construct a reference by itself, so that the section is
 still linked to from the table of contents.  The third (second) argument
 of \v{\\sec#3} (\v{\\sec#2}) is simply the header, which is also the
 'caption' associated with the reference.  The number level
 associated with the reference is automatically initialized and incremented
 when appropriate.
 The document that you are now reading contains nested sections. The
 section macros used here are still somewhat more advanced, (ok, complex),
 and the associated toc macros have to track the level number as well.

\par
 Below you see the \v{\\sec#3} definition.  Remember that the
 \pr{formatted#1} key eats away \it{all} whitespace in its argument (except
 the white space in at scope), and maps format sequences \v{\\%..%}
 (except those in at scope) onto white space, 
 \it{inserting} that in the argument.

\begin{vbt}
\\formatted{
   \\def{sec#2}{\\sec{}{\\1}{\\2}}
\\:
\\: Section: first argument is toc yes/no ("*" for no)
\\:          second argument is anchor, third is caption.
\\:
   \\def{sec#3}{
      \\inc{man::sec}
      \\setx{_ref}{
         \\ifeq{\\2}{}{
            _section_\\ctrput{man::sec}
         }{
            \\2
         }
      }
      \\ifeq{\\1}{*}{}{
         \\write{\\$base.zmt}{copy}{
            \\meta{"man::tocentry"}{o}{
               {\\_ref}
               {1}
               {Section}
               {\\ctrput{man::sec}}
               {\\3}
               \\%n%
            }
         }
      }
      \\write{\\$base.zmr}{copy}{
         \\meta{refload}{o}{
            {\\_ref}
            {1}
            {Section}
            {\\ctrput{man::sec}}
            {\\3}
            {}
            \\%n% \\: this is mapped by \\formatted#1 to a newline.
         }
      }
      \\switch{\\$device}{
         {html}{
            \\@{\\%P%<a name="\\_ref"></a>}
            \\@{\\%N%<h2>} \\3 \\@{</h2>}
         }
         {roff}{
            \\@{\\%N%.SH\\%S%}\\3\\@{\\%N%}
         }
      }
   }

   \: man::tocentry arguments: anchor type number caption

   \\switch{\\$device}{
      {html}{
         \\def{"man::tocbegin"}{
            \\@{<dl compact>\\%N%}
         }
         \\def{"man::tocentry"#4}{
            \\@{\\%N%<dt>}
            \\3.\\@{<dd>}\\@{<a href="#\\1">}\\4\\@{</a>\\%N%}
         }
         \\def{"man::tocend"}{\\@{\\%B%</dl>\\%N%}}
      }
      {roff}{
         \\def{"man::tocbegin"}{
            \\@{\\%P%.de xl\\%N%.ta 0.0i 0.5i\\%N%\\\\\\\\$1\\\\t\\%N%..\\%N%}
         }
         \\def{"man::tocentry"#4}{
            \\@{\\%N%.xl "}\\3.\\@{"\\%N%}\\4\\@{\\%N%.br\\%N%}
         }
         \\def{"man::tocend"}{}
      }
   }
   \\def{maketoc}{
      \\"man::tocbegin"
      \\"man::toclist"
      \\"man::tocend"
         \\:  \\"man::toclist" is created by the \\preamble key as follows:
         \\:  \\store{"man::toclist"}{\\$base.zmt}
   }
}
\end{vbt}

\par
 \v{\\inc#1} is a \lref{builtin}{built-in macro} and wraps around
 \pr{ctradd#2} -
 \v{\\inc{foo}} is equivalent to \v{\\ctradd{foo}{1}}, where \v{foo} is a
 label living in the counter name space.  Counters are autovivified; when a
 counter does not yet exist \pr{ctradd#2} creates one and implicitly
 initializes it to zero before adding the second argument as increment.

\par
 The rest is perhaps pretty obvious, apart from the html- and troff-specific
 stuff. The table of contents in this manual contains nested material.
 It is closed with a macro that calls itself until two counters
 are identical:

\begin{vbt}
   \\def{tocclose#1}{
      \\: below recursively closes the table of contents.
      \\icmp{\\ctr{tut::tocnillevel}}{\\ctr{tut::tocprevlevel}}
      {\\1\\inc{tut::tocnillevel}\\tocclose{\\1}}
      {}
      {}
   }
   \\: used e.g. as \\tocclose{\\@{\\%B%</dl>\\%N%}}
\end{vbt}

 This is not particularly brilliant, but it works. It could also
 have been implemented using \pr{while#2}.

\sec1{glossary}{Glossary}
 For \bf{user keys}, \bf{dollar keys}, and \bf{dictionary stacks},
 refer to the \cref{dictionary} section and the \cref{macro} section.

\par
 For \bf{key signatures} and \bf{key mention}, refer to the \cref{signature}
 section.  For \bf{anonymous keys}: the \cref{anonymous} section.

\par
 For \bf{varargs}, arguments in which a variable number of sub-arguments
 can be stored, and for \bf{blocks}: the \cref{vararg} section.

\par
 For \bf{plain scope}, \bf{device scope}, \bf{at scope}, and \bf{glyph
 sequences}: The \cref{dichotomy} and \cref{dscope} sections.

\par
 For file read and  \bf{inline files}: the \cref{fileread} section.

\: mq
\postamble

\=tut.zmm==
\switch{\$device}{
   {html}{}
   {roff}{
    \write{stderr}{txt}{Roff support must be fixed before use!\|\exit}
   }
   {\write{stderr}{txt}{No support for device "\$device" (in file \$file)\|}\exit
   }
}


\def{"tut::html-title"}{t*i*t*l*e}
\def{"tut::title"}{t*i*t*l*e}
\def{"tut::year-title"}{y*e*a*r}
\def{"tut::author"}{a*u*t*h*o*r}


\${html}{
   \def{hrule}{\@{<hr noshade size="1">}}
   \def{prule}{\@{<div style="margin-top:1em"><hr noshade size="1"></div>}}
   \env{center}{\@{<div align=center>\%N%}}{\@{</div>\%N%}}
}


\formatted{
   \switch{\$device}{
      {html}{
         \def{href#2}{ \@{<a href="\1">}\2\@{</a>} }
         \def{lref#2}{ \@{<a href="#\1">}\2\@{</a>} }
      }
      {roff}{
      }
   }
}


\formatted{
   \def{preamble}{
      \ctrset{tut::sec1}{0}
      \ctrset{tut::sec2}{0}
      \load{\$base.zmr}
      \store{toclist}{\$base.zmt}
      \${roff}{
      }
      \${html}{
         \@{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\%N%}
         \@{<html>\%N%}
         \@{<!-- Copyright (c)\%S%}\"tut::year"\%s%\"tut::author"\@{\%S%-->\%N%}
            \@{\%T%<head>\%N%}
               \@{\%T%<style type="text/css">\%N%}
                  \@{\%T%body {text-align: justify}\%N%}
                  \@{body        { color: #001111 ; background: white; }\%N%}
                  \@{body        { margin-left: 8%; margin-right: 8%; }\%N%}
                  \@{div.indent  { margin-left: 8%; margin-right: 0%;}\%N%}
                  \@{a:link      { text-decoration: none; }\%N%}
                  \@{a:active    { text-decoration: none; }\%N%}
                  \@{a:visited   { text-decoration: none; }\%N%}
               \@{\%B%</style>\%N%}
               \@{<title>}\"tut::html-title"\@{\%N%}
               \@{</title>\%N%}
            \@{\%B%</head>\%N%}
         \@{\%B%<body>\%N%}
         \@{<p style="text-align:right">\%N%}
         \"tut::day"\%s%\"tut::month"\%s%\"tut::year"
         \@{</p>\%N%}
         \@{<h1 align=center>} \"tut::title" \@{</h1>\%N%}
      }
   }
   \def{postamble}{
      \${html}{\@{\%P%</html>\%N%</body>}}
      \${roff}{}
   }
}


\switch{\$device}{
   {html}{
      \def{par#1}{\@{\%P%<p align=justify>\%N%}\bf{\1}\@{\%N%}\|}
      \def{par}{\@{\%P%<p>\%N%}}

      \env{vbt}{\@{\%P%<pre>\%w%}}{\@{\%W%</pre>\%N%}}
      \def{vbt#1}{\@{<tt>}\1\@{</tt>}}

      \env{quote}{\@{\%P%<blockquote>}}{\@{</blockquote>\%N%}}

      \env{cite}{\@{\%P%<cite>}}{\@{</cite>\%N%}}

      \env{cblist}{
         \@{\%P%<ul type=bullet style="margin-top:1em" compact>}
         }{
         \@{</ul>\%N%}
         }

      \env{itemize}{
         \: \@{\%P%<dl compact style="margin-top:1em">\%N%}
         \: }{
         \@{\%P%<dl compact style="margin-top:1em">\%N%}
         }{
         \@{\%N%</dl><!-- ^_^ -->\%N%}
         }
      \def{itemnew}{}
      \def{item#1}{\@{\%N%<dt>}\1\@{\%N%}}
      \def{citem#1}{\@{\%N%<dt>}\1\@{\%N%}}
      \def{itemdef}{\@{\%N%<dd>\%N%}}
      \def{itemend}{\|\|}
   }
   {roff}{
      \def{par#1}{\@{\%P%}\bf{\1}\@{\%N%}\|}
      \def{par}{\@{\%P%}}
      \env{bt}{\@{\%P%.nf \\fC\%Sw%}}{\@{\%WN%.fi \\fR\%P%}}
   }
}


\switch{\$device}{
   {html}{
      \special{
         {38}  {&amp;}
         {60}  {&lt;}
         {62}  {&gt;}
         {256} {&nbsp;}          \: the zoem escape \~
         {257} {<br>\%N%}        \: the zoem escape \|
         {258} {-}               \: the zoem escape \-
      }
      \constant{
         {'e}  {&eacute;}        \: 
         {`e}  {&egrave;}        \: 
         {(c)} {&copy;}          \: 
         {+-}  {&plusmn;}        \: 
      }
   }
   {roff}{
      \special{
         {46}  {\\.}
         {96}  {\\`}
         {92}  {\\\\}
         {256} {\\ }             \: the zoem escape \~
         {257} {\%N%.br\%N%}     \: the zoem escape \|
         {258} {\\-}             \: the zoem escape \-
      }
   }
}

\switch{\$device}{
   {html}{
      \def{bf#1}{\@{<b>}\1\@{</b>}}
      \def{it#1}{\@{<i>}\1\@{</i>}}
      \def{tt#1}{\@{<tt>}\1\@{</tt>}}
   }
   {roff}{
      \def{bf#1}{\@{\\fB}\1\@{\\fP}}
      \def{it#1}{\@{\\fI}\1\@{\\fP}}
      \def{tt#1}{\1}
   }
}


\formatted{
   \def{sec1#2}{\sec1{}{\1}{\2}}
\:
\: Section: first argument is toc yes/no ('*' for no)
\:          second argument is anchor, third is caption.
\:
   \def{sec1#3}{
      \inc{tut::sec1}
      \inc{tut::section-step}
      \inc{tut::section-next}
      \ctrset{tut::sec2}{0}
      \setx{_ref}{
         \ifeq{\2}{}{
            _section_\ctrput{tut::sec1}
         }{
            \2
         }
      }
      \ifeq{\1}{*}{}{
         \write{\$base.zmt}{copy}{
            \meta{tocentry}{o}{
               {\_ref}
               {1}
               {Section}
               {\ctrput{tut::sec1}}
               {\3}
               \%n%
            }
         }
      }
      \write{\$base.zmr}{copy}{
         \meta{refload}{o}{
            {\_ref}
            {1}
            {Section}
            {\ctrput{tut::sec1}}
            {\3}
            {}
            \%n%
         }
      }
      \switch{\$device}{
         {html}{
            \@{\%CP%<a name="}\_ref
            \@{"></a>}
            \@{\%N%<h2>}
               \@{\%N%<a href="#thetoc" style="color:black">}
               \ctrput{tut::sec1}
               \@{\%N%</a>}
               \~\~\3
            \@{</h2>}
         }
         {roff}{
            \@{\%N%.SH\%S%}\3\@{\%N%}
         }
      }
   }
}


\formatted{
   \def{sec2#2}{\sec2{}{\1}{\2}}
\:
\: Section: first argument is toc yes/no ('*' for no)
\:          second argument is anchor, third is caption.
\:
   \def{sec2#3}{
      \inc{tut::sec2}
      \inc{tut::section-step}
      \inc{tut::section-next}
      \setx{_ref}{
         \ifeq{\2}{}{
            _section_\ctrput{tut::sec1}::\ctrput{tut::sec2}
         }{
            \2
         }
      }
      \ifeq{\1}{*}{}{
         \write{\$base.zmt}{copy}{
            \meta{tocentry}{o}{
               {\_ref}
               {2}
               {Section}
               {\ctrput{tut::sec1}.\ctrput{tut::sec2}}
               {\3}
               \%n%
            }
         }
      }
      \write{\$base.zmr}{copy}{
         \meta{refload}{o}{
            {\_ref}
            {2}
            {Section}
            {\ctrput{tut::sec1}.\ctrput{tut::sec2}}
            {\3}
            {}
            \%n%
         }
      }
      \switch{\$device}{
         {html}{
            \@{\%CP%<a name="}\_ref\@{"></a>}
            \@{\%N%<h3>}
               \@{\%N%<a href="#thetoc" style="color:black">}
               \ctrput{tut::sec1}.\ctrput{tut::sec2}
               \@{\%N%</a>}
               \~\~\3
            \@{</h3>}
         }
         {roff}{
            \@{\%N%.SH\%S%}\3\@{\%N%}
         }
      }
   }
}


\formatted{
   \ctrset{tut::tocprevlevel}{1}
   \ctrset{tut::tocnillevel}{0}
   \def{tocclose#1}{
      \: below recursively closes the table of contents.
      \icmp{\ctr{tut::tocnillevel}}{\ctr{tut::tocprevlevel}}
      {\1\inc{tut::tocnillevel}\tocclose{\1}}
      {}
      {}
   }
   \switch{\$device}{
      {html}{
         \def{tocbegin}{
            \@{<a name="thetoc"></a>}
            \prule
            \@{<dl compact style="margin-top:1em">\%NT%}
         }
         \def{tocend}{
            \tocclose{\@{\%B%</dl>\%N%}}
         }
         \def{maketoc}{
            \tocbegin
            \toclist
            \tocend
         }
      }
      {roff}{
      }
   }
}


\formatted{
\:
\: tocentry arguments: anchor level type number caption
\:
   \def{tocentry#5}{
      \ctrset{tut::toccurlevel}{\2}
      \switch{\$device}{
         {html}{
            \icmp{\ctr{tut::tocprevlevel}}{\ctr{tut::toccurlevel}}{
            \@{\%N%<dl compact>\%TN%<dt>}}{
            \@{\%N%<dt>}}{
            \@{\%B%</dl>\%N%<dt>}
            }
            \4.\@{<dd>}\@{<a href="#\1">}\5\@{</a>\%N%}
            \ctrset{tut::tocprevlevel}{\2}
         }
         {roff}{
            \@{\%N%.xl "}\4.\@{"\%N%}\5\@{\%N%.br\%N%}
         }
      }
   }
}

\formatted{
   \switch{\$device}{
      {html}{
         \def{secref#1}{
            \@{\%N%<a href="#\1">}
            \refcaption{\1}
            \@{</a>}
         }
      }
      {roff}{
         \def{secref#1}{
            \bf{\refcaption{\1}}
         }
      }
   }
}
\==


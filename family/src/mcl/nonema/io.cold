
#include "io.h"
#include "track.h"
#include "util/parse.h"
#include "util/minmax.h"
#include "util/print.h"

int     modeRead    =  'b';

/*
////////////////////////////////////////////////////////////////////////
//
//    mcxMatrix I/O
//
*/

static void report_matrix_size
(  const char*             action
,  const mcxMatrix*           mtx
)  {  char                 report[80]

   ;  sprintf
      (  report, "%s %d x %d matrix"
      ,  action, mtx->N_rows, mtx->N_cols
      )
   ;  fprintf(stderr, "%s\n", report)
;  }


int mcxMatrixFilePeek
(  FILE*                  f_in
,  int                    *p_N_cols
,  int                    *p_N_rows
)  {
      int    foffset          =  ftell(f_in)

   ;  if (IoExpectMagicNumber(f_in, MatrixMagicNumber))
      {  fread(p_N_cols, sizeof(int), 1, f_in)
      ;  fread(p_N_rows, sizeof(int), 1, f_in)
      ;  fseek(f_in, foffset, SEEK_SET)
      ;  return 0
   ;  }
      else
      {  int n_parse
      ;  mcxFpFindInFile(f_in, "(mclheader")
      ;  mcxFpSkipSpace(f_in)

      ;  mcxFpParse(f_in, "mcltype", MCX_PARSE_INSIST)
      ;  mcxFpSkipSpace(f_in)
      ;  mcxFpParse(f_in, "matrix", MCX_PARSE_INSIST)
      ;  mcxFpSkipSpace(f_in)
      ;  mcxFpFindInFile(f_in, "dimensions")
      ;  mcxFpSkipSpace(f_in)

      ;  n_parse = fscanf(f_in, "%dx%d", p_N_rows, p_N_cols)
      ;  if (n_parse != 2)
         {  *p_N_cols      =  -1
         ;  *p_N_rows   =  -1
         ;  return 1
      ;  }
         else
         {  fseek(f_in, foffset, SEEK_SET)
         ;  return 0
      ;  }
   ;  }
;  }


mcxMatrix* mcxMatrixMaskedRead
(  FILE*                   f_in
,  const mcxVector*        selector
)  {  mcxMatrix*              m              =  NULL
   ;  int                  N_rows   =  0
   ;  int                  N_cols      =  0

   ;  modeRead                            =  'b'

   ;  if (IoExpectMagicNumber(f_in, MatrixMagicNumber))
      {  int               n_ivps         =  selector ? selector->n_ivps : 0
      
      ;  fread(&N_cols, sizeof(int), 1, f_in)
      ;  fread(&N_rows, sizeof(int), 1, f_in)

      ;  m        =  mcxMatrixAllocZero(N_cols, N_rows)
      ;  if (m)
         {  mcxVector*        vec            =  m->vectors

         ;  if (selector)
            {  int         f_pos          =  ftell(f_in)
            ;  int         k              =  0
            ;  int         v_pos

            ;  while (k < n_ivps)
               {  int      vec_idx        =  selector->ivps[k].idx

               ;  fseek(f_in, f_pos + vec_idx * sizeof(int), SEEK_SET)
               ;  v_pos = IoReadInteger(f_in)
               ;  fseek(f_in, v_pos, SEEK_SET)
               ;  mcxVectorEmbedRead(vec + vec_idx, f_in)
               ;  k++
            ;  }

               /*
               // Move to end of matrix body
               //
               */            
            ;  fseek(f_in, f_pos + N_cols * sizeof(int), SEEK_SET)
            ;  v_pos = IoReadInteger(f_in)
            ;  fseek(f_in, v_pos, SEEK_SET)
         ;  }
            else
            {  fseek(f_in, ((1 + N_cols) * sizeof(int)), SEEK_CUR)
            ;  while (--N_cols >= 0)
                  mcxVectorEmbedRead(vec++, f_in)
         ;  }
         
         ;  if (nonemaVerbose)
               report_matrix_size("[mcl matrix input] read", m)
      ;  }
   ;  }
      else
      {  if (nonemaVerbose)
            fprintf
            (  stderr
            ,  "[mcl matrix input] File not recognizable as "
               "native binary format\n"
               "[mcl matrix input] Trying to read native ascii format\n"
            )
      ;  m  =  mcxMatrixReadAscii(f_in)
      ;  modeRead       =     'a'
   ;  }
   ;  return m
;  }


int mcxMatrixWrite
(  const mcxMatrix*        m
,  FILE*                   f_out
)  {  int                  N_cols   =  m->N_cols
   ;  mcxVector*              vec         =  m->vectors
   ;  int                  code        =  0
   ;  int                  v_pos       =  0

   ;  IoWriteMagicNumber(f_out, MatrixMagicNumber)
   
   ;  fwrite(&N_cols, sizeof(int), 1, f_out)
   ;  fwrite(&m->N_rows, sizeof(int), 1, f_out)

      /*
      // Write vector offsets (plus one for end of matrix body)
      //
      */
   ;  v_pos = ftell(f_out) + (1 + N_cols) * sizeof(int)
   ;  while (--N_cols >= 0)
      {  IoWriteInteger(f_out, v_pos)
      ;  v_pos += sizeof(int) + vec->n_ivps * sizeof(mcxIvp)
      ;  vec++
   ;  }
   ;  IoWriteInteger(f_out, v_pos)

      /*
      // Write vectors
      //
      */   
   ;  N_cols   =  m->N_cols
   ;  vec         =  m->vectors

   ;  while (--N_cols >= 0)
      {  code = mcxVectorEmbedWrite(vec, f_out)
      ;  if (code) break
      ;  vec++
   ;  }
   
   ;  if (nonemaVerbose)
         report_matrix_size("[mcl matrix output] wrote native binary", m)
   ;  return code
;  }


mcxMatrix* mcxMatrixReadAscii
(  FILE*                   f_in
)  {  mcxMatrix*              m              =  NULL
   ;  int                  N_rows   =  0
   ;  int                  N_cols      =  0
   ;  int                  n_parse
   ;  char*                fmt            =  (char *) "%dx%d"

   ;  mcxFpFindInFile(f_in, "(mclheader")
   ;  mcxFpSkipSpace(f_in)

   ;  mcxFpParse(f_in, "mcltype", MCX_PARSE_INSIST)
   ;  mcxFpSkipSpace(f_in)
   ;  mcxFpParse(f_in, "matrix", MCX_PARSE_INSIST)
   ;  mcxFpSkipSpace(f_in)
   ;  mcxFpFindInFile(f_in, "dimensions")
   ;  mcxFpSkipSpace(f_in)

   ;  n_parse = fscanf(f_in, fmt, &N_rows, &N_cols)
   ;  if (n_parse != 2)
      {  fprintf
         (  stderr
         ,  "[mcxMatrixReadAscii] <dimensions NUMxNUM> format not found\n"
         )
      ;  exit(1)
   ;  }

   ;  m = mcxMatrixAllocZero(N_cols, N_rows)

   ;  if (m)
      {  mcxIvpBuf         buf
      ;  mcxIvpBufInit(&buf, 40, 1.66)

      ;  mcxFpFindInFile(f_in, "(mclmatrix")
      ;  mcxFpFindInFile(f_in, "begin")
      ;  for (;;)
         {  int            cidx
         ;  mcxVector*     vec

         ;  if (')' == mcxFpSkipSpace(f_in)) break
         ;  cidx = mcxFpParseNumber(f_in)
         ;  if (cidx < 0 || cidx >= N_cols)
            {  fprintf
               (  stderr
               ,  "[mcxMatrixReadAscii] "
                  "invalid column specification [%d] for column index\n"
               ,  cidx
               )
            ;  mcxMatrixFree(&m)
            ;  exit(1)
         ;  }

         ;  vec = m->vectors + cidx
         ;  for (;;)
            {  if ('$' == mcxFpSkipSpace(f_in))
               {  fgetc(f_in)
               ;  break
            ;  }

               {  int      idx      =  mcxFpParseNumber(f_in)
               ;  float    val      =  (':' == mcxFpSkipSpace(f_in))
                                    ?  (  fgetc(f_in)
                                       ,  mcxFpParseNumber(f_in)
                                       )
                                    :  1.0
               ;  mcxIvpBufStore(&buf, idx, val)
               ;  if (idx < 0 || idx > N_rows || val < 0)
                  {  fprintf
                     (  stderr
                     ,  "[mcxMatrixReadAscii] "
                        "offending index-value pair specification [%d:%f] "
                        "at column [%d]\n"
                     ,  idx,  val, cidx
                     )
                  ;  mcxMatrixFree(&m)
                  ;  exit(1)
               ;  }
            ;  }
         ;  }

         ;  if (!mcxVectorInstantiate(vec, buf.n_ivps, buf.ivps))
            {  fprintf
               (  stderr
               ,  "[mcxMatrixReadAscii] mcxVectorInstantiate returned null\n"
               )
            ;  exit(1)
         ;  }
         ;  mcxIvpBufReset(&buf, 0)
         ;  mcxVectorSort(vec, NULL)
         ;  mcxVectorUniqueIdx(vec)
      ;  }
      ;  mcxIvpBufFree(&buf)
   ;  }

   ;  if (nonemaVerbose)
         report_matrix_size("[mcl matrix output] read native ascii", m)
   ;  return m
;  }


void  mcxMatrixList
(  mcxMatrix*        mx
,  FILE*          fp
,  int            x_lo
,  int            x_hi
,  int            y_lo
,  int            y_hi
,  int            width
,  int            digits
,  const char*    msg
)  {  int   i

   ;  if (x_lo<0) x_lo = 0
   ;  if (y_lo<0) y_lo = 0

   ;  if (x_hi>mx->N_cols || x_hi == 0)
         x_hi = mx->N_cols

   ;  if (y_hi>mx->N_rows || y_hi == 0)
         y_hi = mx->N_rows

   ;  for (i=x_lo;i<x_hi;i++)
      {  fprintf(fp, "vec %d, %d ivps\n", i, (mx->vectors+i)->n_ivps)
      ;  mcxVectorList  
         (  mx->vectors+i
         ,  fp
         ,  y_lo
         ,  y_hi
         ,  width
         ,  digits
         ,  "        "
         ,  ""
         )
   ;  }
;  }


void mcxMatrixWriteAscii
(  const mcxMatrix*        mx
,  FILE*                   fp
,  int                     valdigits
)
   {  int   i
   ;  int   idxwidth    =  ((int) log10(mx->N_rows)) + 1

   ;  fprintf  (  fp
               ,  "(mclheader\nmcltype matrix\ndimensions %dx%d\n)\n"
                  "(mclmatrix\nbegin\n"
               ,  mx->N_rows
               ,  mx->N_cols
               )           

   ;  for (i=0;i<mx->N_cols;i++)
      {  mcxVectorDumpAscii
               (  mx->vectors+i
               ,  fp
               ,  i
               ,  idxwidth
               ,  valdigits
               ,  0
               )
   ;  }
   ;  fprintf(fp, ")\n")
   ;  if (nonemaVerbose)
         report_matrix_size("[mcl matrix output] wrote native ascii", mx)
;  }


void mcxFlowPrettyPrint
(  const mcxMatrix*        mx
,  FILE*                   fp
,  int                     digits
,  const char              msg[]
)
   {  int   i, t
   ;  char     bgl[]       =  " [ "
   ;  char     eol[]       =  "  ]"
   ;  char*    voidstring  =  malloc((digits+1)*sizeof(char))
   ;  mcxMatrix*  tp          =  mcxMatrixTranspose(mx)
   ;  memset(voidstring, ' ', digits)
   ;  *(voidstring+digits) = '\0'

   ;  for (i=0;i<tp->N_cols;i++)
      {  int      last        =  0
      ;  mcxIvp*     ivpPtr      =  (tp->vectors+i)->ivps
      ;  mcxIvp*     ivpPtrMax   =  ivpPtr + (tp->vectors+i)->n_ivps

      ;  fprintf(fp, "%s", bgl)
      ;  while (ivpPtr < ivpPtrMax)

         {  for (t=last;t<ivpPtr->idx;t++) fprintf(fp, "%s-- ", voidstring)
         ;  fprintf(fp, " %*.*f", digits+2, digits, ivpPtr->val)
         ;  last = (ivpPtr++)->idx + 1
      ;  }

      ;  for (t=last;t<tp->N_rows;t++) fprintf(fp, "%s-- ", voidstring)
      ;  fprintf(fp, "%s\n", eol)
   ;  }

   ;  mcxMatrixFree(&tp)
   ;  fprintf(fp, "^ %s\n\n", msg)
;  }


void              mcxMatrixBoolPrint
(  mcxMatrix*        mx
,  int            mode
)  {  int      i, t                 
   ;  const char  *space   =  mode & 1 ? "" : " "
   ;  const char  *empty   =  mode & 1 ? " " : "  "

   ;  fprintf(stdout, "\n  ")        
   ;  for (i=0;i<mx->N_rows;i++)    
      {  fprintf(stdout, "%d%s", i % 10, space)   
   ;  }
   ;  fprintf(stdout, "\n")

   ;  for (i=0;i<mx->N_cols;i++)
      {  int      last        =  0
      ;  mcxIvp*     ivpPtr      =  (mx->vectors+i)->ivps
      ;  mcxIvp*     ivpPtrMax   =  ivpPtr + (mx->vectors+i)->n_ivps
      ;  fprintf(stdout, "%d ", i%10)
                                    
      ;  while (ivpPtr < ivpPtrMax) 

         {  for (t=last;t<ivpPtr->idx;t++) fprintf(stdout, "%s", empty)
         ;  fprintf(stdout, "@%s", space)
         ;  last = (ivpPtr++)->idx + 1
      ;  }        

      ;  for (t=last;t<mx->N_rows;t++) fprintf(stdout, "%s", empty)
      ;  fprintf(stdout, " %d\n", i%10)   
   ;  }           
   ;  fprintf(stdout, "  ")
   ;  for (i=0;i<mx->N_rows;i++)
      {  fprintf(stdout, "%d%s", i % 10, space)
   ;  }
   ;  fprintf(stdout, "\n")
;  }              


void  mcxVectorList
(  mcxVector*        vec
,  FILE*          fp
,  int            lo
,  int            hi
,  int            width
,  int            digits
,  const char*    pre
,  const char*    msg
)  {  mcxIvp*        ivpPtr      =  vec->ivps
   ;  mcxIvp*        ivpPtrMax   =  vec->ivps + vec->n_ivps

   ;  while (ivpPtr < ivpPtrMax)
      {  if (ivpPtr->idx < lo)
         {  ivpPtr++
         ;  continue
      ;  }
         else if (ivpPtr->idx >= hi)
            break

      ;  fprintf
         (  fp, "%s%-10d  %*.*f\n"
         ,   pre
         ,   ivpPtr->idx
         ,   width
         ,   digits
         ,   (ivpPtr)->val
         )
      ;  ivpPtr++
   ;  }
;  }


void mcxVectorDumpAscii
(  const mcxVector*        vec
,  FILE*                   fp
,  int                     idfidx         /* identifies vector */
,  int                     idxwidth
,  int                     valdigits
,  int                     doHeader
)  {  int i
   ;  int nr_chars   =     0
   ;  int fieldwidth =     idxwidth+1
   ;  const char* eov =    "$\n"

                                          /* works for 0.xxx 1.xxx .. */
   ;  if (valdigits) fieldwidth += valdigits + 3
   ;  if (!vec) voidVectorAlert("mcxVectorDumpAscii")

   ;  if (doHeader)
      {  fprintf(fp , "(mclheader\nmcltype vector\n)\n" "(mclvector\nbegin\n")
      ;  eov         =     "\n)\n"
   ;  }

   ;  if (idfidx>=0)
      {  fprintf(fp, "%-*d  ", idxwidth, idfidx)
      ;  nr_chars = idxwidth + 2
   ;  }

   ;  for (i=0; i<vec->n_ivps;i++)
      {  if (valdigits)
         {  fprintf  (  fp, "%*d:%-*.*f "
                     ,  idxwidth, (vec->ivps+i)->idx
                     ,  valdigits+2, valdigits, (vec->ivps+i)->val
                     )
         ;  nr_chars += idxwidth + valdigits + 4   /* 4 chars: [01]\.\:\ */
      ;  }
         else
         {  fprintf  (  fp, "%*d "
                     ,  idxwidth, (vec->ivps+i)->idx
                     )
         ;  nr_chars += idxwidth + 1
      ;  }
      ;  if (  (  (i<vec->n_ivps-2)
               && (nr_chars + fieldwidth > 80) 
               )
            ||
               (  (i==vec->n_ivps-2)
               && (nr_chars + fieldwidth + strlen(eov) > 80)
               )
            )
         {  int j
         ;  fprintf  (fp, "\n")
                                       /* below is _very_ stupid */
         ;  for (j=0;j<idxwidth+2;j++) fprintf(fp, " ")
         ;  nr_chars =  idxwidth+2
      ;  }
   ;  }
   ;  fprintf(fp, "%s", eov)
;  }

/*
//    mcxVector I/O
*/

static void report_vector_size
(  const char*             action
,  const mcxVector*           vec
)  {  char                 report[80]

   ;  sprintf
      (  report, "%s %d pair%s"
      ,  action
      ,  vec->n_ivps
      ,  vec->n_ivps == 1 ? "" : "s"
      )
   ;  fprintf(stderr, "%s\n", report)
;  }

   /*
   // mcxVectorEmbedRead: vec argument may be NULL.
   */

int mcxVectorEmbedRead
(  mcxVector*                 vec
,  FILE*                   f_in
)  {  int                  n_ivps            =  0

   ;  n_ivps = IoReadInteger(f_in)

   ;  if
      (  n_ivps
      && mcxVectorInstantiate(vec, n_ivps, NULL)
      )  {  fread(vec->ivps, sizeof(mcxIvp), n_ivps, f_in)
         ;  mcxVectorSort(vec, NULL)
         ;  mcxVectorUniqueIdx(vec)
         ;  return 0
   ;     }
      else
      {  fprintf(stderr, "[mcxVectorEmbedRead] mcxVector has zero elements\n")
      ;  mcxVectorInstantiate(vec, 0, NULL)
   ;  }
   ;  return 0
;  }


   /*
   // mcxVectorRead: vec argument may be NULL.
   */

mcxVector* mcxVectorRead
(  mcxVector*                 vec
,  FILE*                   f_in
)  {  if (!IoExpectMagicNumber(f_in, mcxVectorMagicNumber))
      {  fprintf
         (  stderr
         ,  "[mcxVectorRead] Did not find magic number\n"
            "[mcxVectorRead] Trying to read ascii format\n"
         )
      ;  return mcxVectorReadAscii(f_in)
   ;  }
      else
      {  mcxVector*           new_vec = mcxVectorInit(vec)
      ;  mcxVectorEmbedRead(new_vec, f_in)
      ;  return new_vec
   ;  }
;  }


mcxVector* mcxVectorReadAscii
(  FILE*                   f_in
)  {  mcxVector*              vec            =  mcxVectorInit(NULL)

   ;  mcxFpFindInFile(f_in, "(mclheader")
   ;  mcxFpSkipSpace(f_in)

   ;  mcxFpParse(f_in, "mcltype", MCX_PARSE_INSIST)
   ;  mcxFpSkipSpace(f_in)
   ;  mcxFpParse(f_in, "vector", MCX_PARSE_INSIST)
   ;  mcxFpSkipSpace(f_in)

   ;  {  mcxIvpBuf         buf
      ;  mcxIvpBufInit(&buf, 40, 1.66)

      ;  mcxFpFindInFile(f_in, "(mclvector")
      ;  mcxFpFindInFile(f_in, "begin")
      ;  for (;;)
         {  if (')' == mcxFpSkipSpace(f_in))  break

         ;  {  int      idx      =  mcxFpParseNumber(f_in)
            ;  float    val      =  (':' == mcxFpSkipSpace(f_in))
                                 ?  (  fgetc(f_in)
                                    ,  mcxFpParseNumber(f_in)
                                    )
                                 :  1.0
            ;  mcxIvpBufStore(&buf, idx, val)
         ;  }
      ;  }

      ;  if (!mcxVectorInstantiate(vec, buf.n_ivps, buf.ivps))
         {  fprintf
            (  stderr
            ,  "[mcxMatrixReadAscii] mcxVectorInstantiate failed\n"
            )
         ;  exit(1)
      ;  }
      ;  mcxIvpBufFree(&buf)
      ;  mcxVectorSort(vec, NULL)
      ;  mcxVectorUniqueIdx(vec)
   ;  }
   ;  return vec
;  }

int mcxVectorEmbedWrite
(  const mcxVector*        vec
,  FILE*                   f_out
)  {  if (!vec)
      {  voidVectorAlert("mcxVectorEmbedWrite")
      ;  exit(1)
   ;  }

   ;  IoWriteInteger(f_out, vec->n_ivps)
   ;  if (vec->n_ivps)
         fwrite(vec->ivps, sizeof(mcxIvp), vec->n_ivps, f_out)

   ;  return 0
;  }


int mcxVectorWrite
(  const mcxVector*        vec
,  FILE*                   f_out
)  {  int                  code

   ;  if (!vec)
      {  voidVectorAlert("mcxVectorWrite")
      ;  exit(1)
   ;  }

   ;  IoWriteMagicNumber(f_out, mcxVectorMagicNumber)
   ;  code = mcxVectorEmbedWrite(vec, f_out)
   ;  if (!code) report_vector_size("wrote", vec)
   ;  return code
;  }


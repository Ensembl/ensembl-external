
/*
//
*/

#include <string.h>

#include "nonema/matrix.h"
#include "nonema/vector.h"
#include "nonema/ivp.h"
#include "nonema/io.h"
#include "mcl/interpret.h"
#include "util/txt.h"
#include "util/iface.h"
#include "util/buf.h"

#include "intalg/parse.h"
#include "intalg/la.h"


   typedef struct
   {  mcxTxt*     tag
   ;  Ilist*      clist            /*  contains cluster indices   */
   ;  Ilist*      ilist            /*  contains simple indices    */
;  }
subSpec       ;
                                   /*  All indices in all clusters with
                                    *  labels in clist, plus all indices
                                    *  in ilist generate one submatrix.
                                    *  It is put in a filename ending with tag.
                                    */
int main
(  int                  argc
,  const char*          argv[]
)  {  
      mcxIOstream       *xfCl       =  NULL
   ;  mcxIOstream       *xfMx       =  NULL

   ;  mcxMatrix         *cl         =  NULL
   ;  mcxMatrix         *mx         =  NULL

   ;  mcxTxt            *fstem      =  mcxTxtNew("out.clm-")

   ;  subSpec           *specList   =  NULL
   ;  int               n_spec      =  0
   ;  mcxBuf            specBuf

   ;  int               status      =  0
   ;  int               digits      =  8
   ;  int               a           =  1
   ;  int               i           =  0

   ;  mcxBufInit(&specBuf,  &specList, sizeof(subSpec), 30)

   ;  if (argc==1)
      goto help

   ;  while(a < argc)
      {  if (!strcmp(argv[a], "-cl"))
         {  if (a++ + 1 < argc)
            {  xfCl  =  mcxIOstreamNew(argv[a], "r")
            ;  mcxIOstreamOpen(xfCl, EXIT_ON_FAIL)
         ;  }
            else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-stem"))
         {  if (a++ + 1 < argc)
            mcxTxtWrite(fstem, argv[a])
         ;  else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-digits"))
         {  if (a++ + 1 < argc)
            digits   =  atoi(argv[a])
         ;  else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-mx"))
         {  if (a++ + 1 < argc)
            {  xfMx  =  mcxIOstreamNew(argv[a], "r")
            ;  mcxIOstreamOpen(xfMx, EXIT_ON_FAIL)
         ;  }
            else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-h"))
         {  goto help
      ;  }
         else if (0)
         {  die:
            status   =  1
         ;  goto help
      ;  }
         else if (0)
         {  help:
fprintf
(  stdout
,  "\n"
   "[clmsubs usage]\n"
   "clmsubs <options> <idx-spec>+\n"
"\n"
   "Mandatory option:\n"
   "-mx     <fname>  graph in MCL matrix format to which clustering pertains\n"
   "Facultative options:\n"
   "-cl     <fname>  read clustering, must pertain to matrix\n"
   "-stem   <str>    use str as stem for all matrices that are output\n"
   "-digits <int i>  output i significant decimals for each matrix entry\n"
"\n"
   "<idx-spec>    clusters and indices inducing submatrix,\n"
   "              repeated use allowed (resulting in multiple submatrices).\n"
"\n"
   "              'c' or 'C' signifies cluster indices,\n"
   "              'i' or 'I' signifies node indices.\n"
   "              No tag signifies single indices. Integers are specified\n"
   "              by comma-separated singletons and ranges. Examples:\n"
"\n"
   "              c3,5,7-10,12i8,30-34\n"
   "                 submatrix induced by both clusters and single indices,\n"
   "                 requires -cl option\n"
   "              c3,5,7-10\n"
   "                 submatrix induced by clusters only, requires -cl\n"
   "              i8,30-34  1,5-7,8,9,10-12\n"
   "                 two submatrices induced by node indices\n"
"\n"
   " special case:\n"
   "              c3--10\n"
   "                 generate separate submatrices for clusters 3..10\n"
   "                 requires -cl, commas are not allowed.\n"
"\n"
)
         ;  exit(status)
      ;  }
         else if (0)
         {  arg_missing:
         ;  fprintf
            (  stderr
            ,  "[clmsubs] Flag %s needs argument; see help (-h)\n"
            ,  argv[argc-1]
            )
         ;  exit(1)
      ;  }
         else if (strstr(argv[a], "--"))
         {
            int left, right, j
         ;  if (2 != sscanf(argv[a], "c%d--%d", &left, &right))
            {
               fprintf
               (  stderr
               ,  "[clmsubs] cannot parse argument [%s] as c<int>--<int>\n"
               ,  argv[a]
               )
            ,  exit(1)
         ;  }
         ;  for (j=left;j<=right;j++)
            {  subSpec* spec     =  (subSpec*) mcxBufExtend(&specBuf, 1)
            ;  spec->clist       =  ilVA(NULL, 1, j)
            ;  spec->tag         =  mcxTxtInteger(NULL, j)
         ;  }
      ;  }
         else
         {  
            mcxTxt*     specTxt  =  mcxTxtNew(argv[a])
         ;  subSpec*    spec     =  (subSpec*) mcxBufExtend(&specBuf, 1)

         ;  char*       Iptr     =  strpbrk(specTxt->str, "iI")
         ;  char*       Cptr     =  strpbrk(specTxt->str, "cC")

         ;  spec->clist          =  NULL
         ;  spec->ilist          =  NULL

         ;  if (Cptr) *Cptr      =  '\0'
         ;  if (Iptr) *Iptr      =  '\0'

         ;  if (Cptr)
            spec->clist          =  ilParseIntSet(Cptr+1, EXIT_ON_FAIL)

         ;  if (Iptr)
            spec->ilist          =  ilParseIntSet(Iptr+1, EXIT_ON_FAIL)

         ;  if (!Cptr && !Iptr)
            spec->ilist          =  ilParseIntSet(argv[a], EXIT_ON_FAIL)

         ;  spec->tag            =  mcxTxtNew(argv[a])
         ;  mcxTxtFree(&specTxt)
      ;  }
      ;  a++
   ;  }

   ;  n_spec =  mcxBufFinalize(&specBuf)

   ;  if (!xfMx)
      {  fprintf
         (  stderr
         ,  "[clmsubs] -mx flag is obligatory, see help (-h)\n"
         )
      ;  exit(1)
   ;  }
      else
      {  mx    =  mcxMatrixRead(xfMx, EXIT_ON_FAIL)
      ;  if (mx->N_cols != mx->N_rows)
            fprintf(stderr, "[clmsubs] matrix is not square!\n")
         ,  exit(1)
   ;  }

   ;  if (xfCl)
      {  
         cl    =  mcxMatrixRead(xfCl, EXIT_ON_FAIL)

      ;  if (cl->N_rows != mx->N_cols)
            fprintf
            (  stderr
            ,  "[clmsubs] matrix dimension [%d]"
               " does not match clustering range [%d]\n"
            ,  mx->N_cols
            ,  cl->N_rows
            )
         ,  exit(1)
   ;  }

   ;  mcxIOstreamFree(&xfMx)
   ;  mcxIOstreamFree(&xfCl)

   ;  for (i=0;i<n_spec;i++)
      {
         mcxMatrix*           sub
      ;  mcxVector*           subVec   =  mcxVectorInit(NULL)

      ;  subSpec*             spec     =  specList+i
      ;  mcxTxt*              tag      =  (specList+i)->tag
      ;  Ilist*               clist    =  (specList+i)->clist
      ;  Ilist*               ilist    =  (specList+i)->ilist

      ;  int                  j        =  0

      ;  mcxTxt               *fname   =  mcxTxtNew(fstem->str)
      ;  mcxIOstream          *xf

      ;  mcxTxtAppend(fname, tag->str)
      ;  subVec                        =  mcxVectorFromIlist(subVec, ilist, 1.0)

      ;  if
         (  mcxVectorCheck(subVec, mx->N_cols, "clmsubs", RETURN_ON_FAIL)
         != STATUS_OK
         )
         {  fprintf
            (  stderr
            ,  "[clmsubs] some single index in 'I' part of specification <%s>\n"
               "  exceeds index range 0-%d\n"
            ,  tag->str
            ,  mx->N_cols - 1
            )
         ;  exit(1)
      ;  }

      ;  if (clist)
         {
            if (!cl)
               fprintf
               (  stderr
               ,  "[clmsubs] specification of cluster indices requires -cl flag\n"
               )
            ,  exit(1)

         ;  for (j=0;j<clist->n;j++)
            {  
               int   clusIdx  =  *(clist->list+j)

            ;  if (clusIdx < 0 || clusIdx >= cl->N_cols)
               {  
                  fprintf
                  (  stderr
                  ,  "[clmsubs] index <%d> out of cluster index bounds [0,%d)\n"
                  ,  clusIdx
                  ,  cl->N_cols
                  )
               ;  exit(1)
            ;  }

            ;  subVec = mcxVectorSetMerge(subVec, cl->vectors+clusIdx, subVec)
         ;  }
      ;  }

      ;  xf    =  mcxIOstreamNew(fname->str, "w")
      ;  if (mcxIOstreamOpen(xf, RETURN_ON_FAIL) == STATUS_FAIL)
         {  fprintf
            (  stderr
            ,  "[clmsubs] cannot open file [%s] for writing! Ignoring\n"
            ,  xf->fn->str
            )
         ;  mcxTxtFree(&fname)
         ;  mcxIOstreamFree(&xf)
         ;  continue
      ;  }

      ;  sub
         =  mcxSubmatrix
            (  mx
            ,  subVec
            ,  subVec
            )
      ;  mcxMatrixWriteAscii(sub, xf, digits, RETURN_ON_FAIL)
      ;  mcxMatrixFree(&sub)
      ;  mcxVectorFree(&subVec)
      ;  mcxTxtFree(&fname)
      ;  mcxIOstreamFree(&xf)
   ;  }

   ;  return 0
;  }


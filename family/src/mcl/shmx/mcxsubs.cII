
/*
//
*/

#include <string.h>

#include "nonema/matrix.h"
#include "nonema/vector.h"
#include "nonema/ivp.h"
#include "nonema/io.h"
#include "mcl/interpret.h"
#include "util/txt.h"
#include "util/iface.h"
#include "util/buf.h"

#include "intalg/parse.h"
#include "intalg/la.h"


   typedef struct
   {  mcxTxt*     tag
   ;  Ilist*      clist            /*  contains cluster indices   */
   ;  Ilist*      ilist            /*  contains simple indices    */
   ;  mcxBoolean  tagIsFname
;  }
subSpec       ;
                                   /*  All indices in all clusters with
                                    *  labels in clist, plus all indices
                                    *  in ilist generate one submatrix.
                                    *  It is put in a filename ending with tag.
                                    */
void usage (void);

int main
(  int                  argc
,  const char*          argv[]
)  {  
      mcxIOstream       *xfCl       =  NULL
   ;  mcxIOstream       *xfMx       =  NULL

   ;  mcxMatrix         *cl         =  NULL
   ;  mcxMatrix         *mx         =  NULL

   ;  mcxTxt            *fstem      =  mcxTxtNew("out.sub-")

   ;  subSpec           *specList   =  NULL
   ;  int               n_spec      =  0
   ;  mcxBuf            specBuf

   ;  int               status      =  0
   ;  int               digits      =  3
   ;  int               a           =  1
   ;  int               i           =  0

   ;  mcxBufInit(&specBuf,  &specList, sizeof(subSpec), 30)

   ;  if (argc==1)
      goto help

   ;  while(a < argc)
      {  if (!strcmp(argv[a], "-cl"))
         {  if (a++ + 1 < argc)
            {  xfCl  =  mcxIOstreamNew(argv[a], "r")
            ;  mcxIOstreamOpen(xfCl, EXIT_ON_FAIL)
         ;  }
            else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-stem"))
         {  if (a++ + 1 < argc)
            mcxTxtWrite(fstem, argv[a])
         ;  else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-digits"))
         {  if (a++ + 1 < argc)
            digits   =  atoi(argv[a])
         ;  else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-mx"))
         {  if (a++ + 1 < argc)
            {  xfMx  =  mcxIOstreamNew(argv[a], "r")
            ;  mcxIOstreamOpen(xfMx, EXIT_ON_FAIL)
         ;  }
            else goto arg_missing;
      ;  }
         else if (!strcmp(argv[a], "-h"))
         {  goto help
      ;  }
         else if (0)
         {  die:
            status   =  1
         ;  goto help
      ;  }
         else if (0)
         {  help:
         ;  usage()
         ;  exit(status)
      ;  }
         else if (0)
         {  arg_missing:
         ;  fprintf
            (  stderr
            ,  "[mcxsubs] Flag %s needs argument; see help (-h)\n"
            ,  argv[argc-1]
            )
         ;  exit(1)
      ;  }
         else if (strstr(argv[a], "--"))
         {
            int left, right, j
         ;  if (2 != sscanf(argv[a], "c%d--%d", &left, &right))
            {
               fprintf
               (  stderr
               ,  "[mcxsubs] cannot parse argument [%s] as c<int>--<int>\n"
               ,  argv[a]
               )
            ,  exit(1)
         ;  }
         ;  for (j=left;j<=right;j++)
            {  subSpec* spec     =  (subSpec*) mcxBufExtend(&specBuf, 1)
            ;  spec->clist       =  ilVA(NULL, 1, j)
            ;  spec->tag         =  mcxTxtInteger(NULL, j)
            ;  spec->tagIsFname  =  0
         ;  }
      ;  }
         else
         {  
            mcxTxt*     specTxt  =  mcxTxtNew(argv[a])
         ;  subSpec*    spec     =  (subSpec*) mcxBufExtend(&specBuf, 1)

         ;  char        thistag  =  argv[a][0]
         ;  char        nexttag  =  '\0'

         ;  char        *thisstr =  specTxt->str
         ;  char        *nextstr

         ;  spec->tag            =  mcxTxtNew(argv[a])
         ;  spec->tagIsFname     =  0
         ;  spec->clist          =  ilInit(NULL)
         ;  spec->ilist          =  ilInit(NULL)

         ;  if (thistag == 'C' || thistag == 'c')
            thisstr++
         ;  else
            thistag = 'i'

         ;  while(1)
            {

              /*  parse rest of string as file tag or file name
               */
               if (thistag == '#')
               {  nextstr        =  NULL
            ;  }
               else if ((nextstr = strpbrk(thisstr, "cCiI#")) != NULL)
               {  nexttag        =  *nextstr
               ;  *nextstr       =  '\0'
            ;  }
            ;  fprintf(stdout, "Parsing [%c %s]\n", thistag, thisstr)


            ;  if (thistag == 'C' || thistag == 'c')
               {  
                  Ilist*   tmp   =  ilParseIntSet(thisstr, EXIT_ON_FAIL)
               ;  ilCon(spec->clist, tmp->list, tmp->n)
               ;  ilFree(&tmp)
            ;  }
               else if (thistag == 'I' || thistag == 'i')
               {  
                  Ilist*   tmp   =  ilParseIntSet(thisstr, EXIT_ON_FAIL)
               ;  ilCon(spec->ilist, tmp->list, tmp->n)
               ;  ilFree(&tmp)
            ;  }
               else if (thistag == '#')
               {  
                  if (*(thisstr) == '#')
                  {  thisstr++
                  ;  spec->tagIsFname  =  1
               ;  }
               ;  if (!strlen(thisstr))
                  {  fprintf
                     (  stderr
                     ,  "[mcxsubs] empty tag after '#' token not allowed\n"
                     )
                  ;  exit(1)
               ;  }
               ;  mcxTxtWrite(spec->tag, thisstr)
            ;  }
               else
               {  
                  fprintf(stdout, "sorry, Stijn's stupid\n")
               ,  exit(1)
            ;  }

            ;  if (!nextstr)
               {  break
            ;  }
               else
               {  thisstr    =  nextstr+1
               ;  thistag    =  nexttag
            ;  }
         ;  }

         ;  mcxTxtFree(&specTxt)
      ;  }
      ;  a++
   ;  }

   ;  n_spec =  mcxBufFinalize(&specBuf)

   ;  if (!xfMx)
      {  fprintf
         (  stderr
         ,  "[mcxsubs] -mx flag is obligatory, see help (-h)\n"
         )
      ;  exit(1)
   ;  }
      else
      {  mx    =  mcxMatrixRead(xfMx, EXIT_ON_FAIL)
      ;  if (mx->N_cols != mx->N_rows)
            fprintf(stderr, "[mcxsubs] matrix is not square!\n")
         ,  exit(1)
   ;  }

   ;  if (xfCl)
      {  
         cl    =  mcxMatrixRead(xfCl, EXIT_ON_FAIL)

      ;  if (cl->N_rows != mx->N_cols)
            fprintf
            (  stderr
            ,  "[mcxsubs] matrix dimension [%d]"
               " does not match clustering range [%d]\n"
            ,  mx->N_cols
            ,  cl->N_rows
            )
         ,  exit(1)
   ;  }

   ;  mcxIOstreamFree(&xfMx)
   ;  mcxIOstreamFree(&xfCl)

   ;  for (i=0;i<n_spec;i++)
      {
         mcxMatrix*           sub
      ;  mcxVector*           subVec   =  mcxVectorInit(NULL)

      ;  subSpec*             spec     =  specList+i
      ;  mcxTxt*              tag      =  (specList+i)->tag
      ;  Ilist*               clist    =  (specList+i)->clist
      ;  Ilist*               ilist    =  (specList+i)->ilist

      ;  int                  j        =  0

      ;  mcxTxt               *fname   =     spec->tagIsFname
                                          ?  mcxTxtInit(NULL)
                                          :  mcxTxtNew(fstem->str)
      ;  mcxIOstream          *xf

      ;  mcxTxtAppend(fname, tag->str)
      ;  subVec                        =  mcxVectorFromIlist(subVec, ilist, 1.0)

      ;  if
         (  mcxVectorCheck(subVec, mx->N_cols, "mcxsubs", RETURN_ON_FAIL)
         != STATUS_OK
         )
         {  fprintf
            (  stderr
            ,  "[mcxsubs] some single index in 'I' part of specification <%s>\n"
               "  exceeds index range 0-%d\n"
            ,  tag->str
            ,  mx->N_cols - 1
            )
         ;  exit(1)
      ;  }

      ;  if (clist)
         {
            if (!cl)
               fprintf
               (  stderr
               ,  "[mcxsubs] specification of cluster indices requires -cl flag\n"
               )
            ,  exit(1)

         ;  for (j=0;j<clist->n;j++)
            {  
               int   clusIdx  =  *(clist->list+j)

            ;  if (clusIdx < 0 || clusIdx >= cl->N_cols)
               {  
                  fprintf
                  (  stderr
                  ,  "[mcxsubs] index <%d> out of cluster index bounds [0,%d)\n"
                  ,  clusIdx
                  ,  cl->N_cols
                  )
               ;  exit(1)
            ;  }

            ;  subVec = mcxVectorSetMerge(subVec, cl->vectors+clusIdx, subVec)
         ;  }
      ;  }

      ;  xf    =  mcxIOstreamNew(fname->str, "w")
      ;  if (mcxIOstreamOpen(xf, RETURN_ON_FAIL) == STATUS_FAIL)
         {  fprintf
            (  stderr
            ,  "[mcxsubs] cannot open file [%s] for writing! Ignoring\n"
            ,  xf->fn->str
            )
         ;  mcxTxtFree(&fname)
         ;  mcxIOstreamFree(&xf)
         ;  continue
      ;  }

      ;  sub
         =  mcxSubmatrix
            (  mx
            ,  subVec
            ,  subVec
            )
      ;  mcxMatrixWriteAscii(sub, xf, digits, RETURN_ON_FAIL)
      ;  mcxMatrixFree(&sub)
      ;  mcxVectorFree(&subVec)
      ;  mcxTxtFree(&fname)
      ;  mcxIOstreamFree(&xf)
   ;  }

   ;  return 0
;  }

const char *usagelines[] = {
"[mcxsubs usage]",
"mcxsubs <options> <idx-spec>+",
"\n",
"Mandatory option:",
"-mx     <fname>  read graph in MCL matrix format",
"Facultative options:",
"-cl     <fname>  read clustering, must pertain to matrix given by -mx",
"-stem   <str>    use str as stem for output file names (default out.sub-)",
"-digits <int i>  output i significant decimals for matrix entries (default 3)",
"\n",
"<idx-spec>    clusters and indices inducing submatrix,",
"              repeated use allowed (resulting in multiple submatrices).",
"\n",
"              Tag 'c' or tag 'C' signifies cluster indices,",
"              Tag 'i' or tag 'I' signifies node indices.",
"              Tag '#' signifies begin of file name tag.",
"              Tag '##' signifies begin of file name.",
"              If present, tag '#' or '##' must be the last tag.",
"\n",
"              Multiple 'c' and 'i' tags in single string are allowed.",
"              Index sets are specified by comma-separated singletons",
"              and ranges. Examples:",
"\n",
"              c3,5,7-10,12i8,30-34",
"                 submatrix induced by both clusters and single indices,",
"                 requires -cl option",
"              c3,5,7-10#-abc",
"                 submatrix induced by clusters only, requires -cl option.",
"                 output goes to file 'stem-abc', where stem is given by -stem",
"              i8,30-34  1,5-7,8,9,10-12",
"                 two submatrices induced by node indices",
"              i8,30-34#xyz  c10,11i200-210##abc",
"                 first submatrix is output to file 'stem-xyz'",
"                 last submatrix is output to file 'abc'",
"\n",
" special case:",
"              c3--10",
"                 generate separate submatrices for clusters 3..10",
"                 requires -cl, commas are not allowed and",
"                 'i', '#' and '##' tokens do not work.",
"\n",

""             /* denotes end of array */
}  ;


void usage
(  void
)  {  
      int i =  0

   ;  while(usagelines[i][0] != '\0')
      {  
         if (usagelines[i][0] == '\n')
         fprintf(stdout, "\n")
      ;  else
         fprintf(stdout, "%s\n", usagelines[i])

      ;  i++
   ;  }

      fprintf(stdout, "[mcxsubs options summary] Printed %d lines\n", i+1)
;  }



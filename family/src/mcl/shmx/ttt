
/*
//
*/

#include "nonema/matrix.h"
#include "nonema/vector.h"
#include "nonema/io.h"
#include "nonema/compose.h"
#include "nonema/track.h"
#include "mcl/interpret.h"
#include <string.h>

int main
(  int                  argc
,  const char*          argv[]
)  {  
      FILE           *fomx          =  NULL

   ;  FILE           **fimcs        =  NULL
   ;  int            *mxActions     =  NULL

   ;  int      TRANSFORM_STOCHASTIC =  1
   ;  int      TRANSFORM_TRANSPOSE  =  2

   ;  mcxMatrix      *lft           =  NULL
   ;  mcxMatrix      *rgt           =  NULL
   ;  mcxMatrix      *dst           =  NULL

   ;  const char     *whoiam        =  "mcxproduct"

   ;  int            a              =  1
   ;  int            n_mx           =  0
   ;  int            i, j
   ;  int            n_vectors      =  -1
   ;  int            vector_range   =  -1

   ;  int            bSubStochastic =  0
   ;  int         bResultStochastic =  0
   ;  int            nSub           =  0
   ;  int            nResult        =  0

   ;  nonemaVerbose                 =  0

   ;  if (argc >= 2 && !strcmp(argv[1], "-h"))
      {  goto help
   ;  }

   ;  if (argc < 3)
      {  fprintf
         (  stderr
         ,  "[%s] at least two arguments required (see -h)\n"
         ,  whoiam
         )
      ;  exit(1)
   ;  }

   ;  if ((fomx = fopen(argv[argc-1], "w")) == NULL)
      {  fprintf
         (  stderr
         ,  "[%s] cannot open file [%s] for writing\n"
         ,  whoiam
         ,  argv[argc-1]
         )  ;
      ;  exit(1)
   ;  }

   ;  if ((mxActions = malloc((argc-1)*sizeof(int))) == NULL)
      {  fprintf
         (  stderr
         ,  "[%s] strange, cannot allocate action descriptors\n"
         ,  whoiam
         )  ;
      ;  exit(1)
   ;  }
   ;  for (j=0;j<argc-1;j++)  mxActions[j] = 0

   ;  if ((fimcs = malloc((argc-1)*sizeof(FILE*))) == NULL)
      {  fprintf
         (  stderr
         ,  "[%s] strange, cannot allocate file ppointers\n"
         ,  whoiam
         )  ;
      ;  exit(1)
   ;  }

   ;  while(a<argc-1)
      {  if (!strcmp(argv[a], "-h"))
         {  help:
         fprintf
         (  stdout
         ,  "[%s] usage:\n"
            "mcxproduct [options] <mx spec> <mx spec>* <mx dst>\n"
            "  <mx dst>    name of file where the product is stored\n"
            "  <mx spec>   <fname | fname %%[sT]+>\n"
            "                 T: take transpose of the matrix in file fname\n"
            "                 s: make matrix stochastic\n"
            "Options:\n"
            "  -s          make each matrix factor and subproduct stochastic\n"
            "  -S          make product stochastic\n"
            "  -n <int j>  prune each subproduct with pruning constant j\n"
            "  -N <int j>  prune product with pruning constant j\n"
         ,  whoiam
         )
         ;  exit(0)
      ;  }
         else if (!strcmp(argv[a], "-s"))
         {  bSubStochastic       =  1
         ;  bResultStochastic    =  1
      ;  }
         else if (!strcmp(argv[a], "-S"))
         {  bResultStochastic    =  1
      ;  }
         else if (!strcmp(argv[a], "-n") && a++ + 1 < argc-1)
         {  nSub              =  atoi(argv[a])
      ;  }
         else if (!strcmp(argv[a], "-N") && a++ + 1 < argc-1)
         {  nResult           =  atoi(argv[a])
      ;  }
         else if (argv[a][0] == '%')
         {  if (n_mx == 0)
            {  fprintf
               (  stderr
               ,  "[%s] no matrix to apply action [%s] to\n"
               ,  whoiam
               ,  argv[a]
               )
         ;  exit(1)
         ;  }
         ;  if (strchr(argv[a], 's'))
            {  mxActions[n_mx-1] |= TRANSFORM_STOCHASTIC
         ;  }
         ;  if (strchr(argv[a], 'T'))
            {  mxActions[n_mx-1] |= TRANSFORM_TRANSPOSE
         ;  }
            if (!mxActions[n_mx-1])
            {  fprintf
               (  stderr
               ,  "[%s] Action token '%%' requires at least one of [sT]\n"
               ,  whoiam
               )
            ;  exit(1)
         ;  }
      ;  }
         else if ((fimcs[n_mx] = fopen(argv[a], "r")) == NULL)
         {  fprintf
            (  stderr
            ,  "[%s] cannot open file [%s] for reading\n"
            ,  whoiam
            ,  argv[a]
            )  ;
         ;  exit(1)
      ;  }
         else
         {  n_mx++
      ;  }
      ;  a++
   ;  }


   ;  if (n_mx < 1)
      {  fprintf(stderr, "[%s] at least one matrix factor required\n", whoiam)
      ;  exit(1)
   ;  }
      else if
      (  mcxMatrixPeek
         (  fimcs[0]
         ,  &n_vectors
         ,  &vector_range
         )
         != 0
      )
      {  fprintf
         (  stderr
         ,  "[%s] matrix format not known for first matrix\n"
         ,  whoiam
         )  ;
      ;  exit(1)
   ;  }

   ;  if (mxActions[0] & TRANSFORM_TRANSPOSE)
      {  int   t        =  n_vectors
      ;  n_vectors      =  vector_range
      ;  vector_range   =  t
   ;  }

   ;  for (j=1;j<n_mx;j++)
      {
         int new_vector_range, new_n_vectors
      ;  if
         (  mcxMatrixPeek
            (  fimcs[j]
            ,  &new_n_vectors
            ,  &new_vector_range
            )
            != 0
         )
         {  fprintf
            (  stderr
            ,  "[%s] matrix format not known for matrix %d\n"
            ,  whoiam, j
            )  ;
         ;  exit(1)
      ;  }

      ;  if (mxActions[j] & TRANSFORM_TRANSPOSE)
         {  int   t        =  new_n_vectors
         ;  new_n_vectors  =  new_vector_range
         ;  new_vector_range= t
      ;  }  

      ;  if (n_vectors != new_vector_range)
         {  fprintf
            (  stderr
            ,  "[%s] dimensions [%d, %d] do not fit (matrices %d, %d)\n"
            ,  whoiam
            ,  n_vectors   ,  new_vector_range
            ,  n_mx-1,  n_mx
            )  ;
         ;  exit(1)
      ;  }
         else
         {  n_vectors      =  new_n_vectors
         ;  vector_range   =  new_vector_range
      ;  }
   ;  }

   ;  lft   =  mcxMatrixRead(fimcs[0])
   ;  if (mxActions[0] & TRANSFORM_TRANSPOSE)
      {  mcxMatrix* ltp    =  mcxMatrixTranspose(lft)
      ;  mcxMatrixFree(&lft)
      ;  lft               =  ltp
   ;  }
   ;  if (bSubStochastic || (mxActions[j] & TRANSFORM_STOCHASTIC))
      {  mcxMatrixMakeStochastic(lft)
   ;  }

   ;  for (j=1;j<n_mx;j++)
      {  rgt   =  mcxMatrixRead(fimcs[j])
      ;  if (mxActions[j] & TRANSFORM_TRANSPOSE)
         {  mcxMatrix*  rtp   =  mcxMatrixTranspose(rgt)
         ;  mcxMatrixFree(&rgt)
         ;  rgt               =  rtp
      ;  }
      ;  if (bSubStochastic || (mxActions[j] & TRANSFORM_STOCHASTIC))
         {  mcxMatrixMakeStochastic(rgt)
      ;  }

      ;  dst   =  mcxMatrixCompose(lft, rgt, 0)
      ;  lft   =  dst
      ;  mcxMatrixFree(&rgt)

      ;  if (nSub)
         {  mcxMatrixMakeSparse(lft, nSub)
         ;  if (bSubStochastic)
            {  mcxMatrixMakeStochastic(lft)
         ;  }
      ;  }
   ;  }

   ;  if (nResult)
      {  mcxMatrixMakeSparse(lft, nResult)
      ;  if (bSubStochastic)
         {  mcxMatrixMakeStochastic(lft)
      ;  }
   ;  }

   ;  mcxMatrixWriteAscii(lft, fomx, 8)
   ;  mcxMatrixFree(&lft)
   ;  return(0)
;  }

